#!/usr/bin/env bash

# Default values
BUILD_TYPE="Debug"
BUILD_DIR="build"
INSTALL_DIR="install"
SANITIZER=""
CONFIG_FILE=".build.config"
VERBOSE=false
DRY_RUN=false
CCACHE_ENABLED=false
CLEAN_ONLY=false
RUN_TESTS=false
RUN_LINT=false
COMPILER=""
INSTALL_PREFIX=""
COVERAGE=false
BENCHMARK=false
PARALLEL_JOBS=$(nproc 2>/dev/null || echo 4)
TARGET=""
GENERATOR="Ninja"

# Cross-compilation
CROSS_COMPILE=""

# Pre-allocate arrays for better performance
CMAKE_ARGS=()
CMAKE_CXX_FLAGS=()

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color
GRAY='\e[90m'

# Logging functions
log_info() { echo -e "${BLUE}ℹ${GRAY} $*" >&2; }
log_success() { echo -e "${GREEN}✓${NC} $*" >&2; }
log_warning() { echo -e "${YELLOW}⚠${YELLOW} $*" >&2; }
log_error() { echo -e "${RED}✗${RED} $*" >&2; }
log_cross() { echo -e "${MAGENTA}🔧${GRAY} $*" >&2; }

# Cross-compilation toolchain configurations
declare -A CROSS_TOOLCHAINS=(
	# ARM 32-bit
	["arm32_toolchain"]="arm-linux-gnueabihf"
	["arm32_cmake_file"]="arm-linux-gnueabihf.cmake"
	["arm32_arch"]="armv7-a"
	["arm32_fpu"]="neon-vfpv4"
	["arm32_processor"]="arm"

	# ARM 64-bit (aarch64)
	["aarch64_toolchain"]="aarch64-linux-gnu"
	["aarch64_cmake_file"]="aarch64-linux-gnu.cmake"
	["aarch64_arch"]="armv8-a"
	["aarch64_processor"]="aarch64"

	# Raspberry Pi 3/4
	["rpi3_toolchain"]="arm-linux-gnueabihf"
	["rpi3_cmake_file"]="rpi3.cmake"
	["rpi3_arch"]="armv8-a"
	["rpi3_fpu"]="neon-fp-armv8"
	["rpi3_processor"]="arm"

	["rpi4_toolchain"]="aarch64-linux-gnu"
	["rpi4_cmake_file"]="rpi4.cmake"
	["rpi4_arch"]="armv8-a"
	["rpi4_processor"]="aarch64"
)

# Sanitizer configurations (centralized for maintainability)
declare -A SANITIZER_CONFIGS=(
	["asan_linker"]="-fsanitize=address,undefined,leak"
	["asan_cxx"]="-fsanitize=address,undefined,leak -fno-omit-frame-pointer -fno-optimize-sibling-calls"
	["asan_env"]="new_delete_type_mismatch=0:detect_leaks=1:strict_init_order=1:check_initialization_order=1:symbolize=1:verbosity=1"
	["msan_linker"]="-fsanitize=memory"
	["msan_cxx"]="-fsanitize=memory -fno-omit-frame-pointer -fno-optimize-sibling-calls"
	["msan_env"]="verbosity=1"
	["tsan_linker"]="-fsanitize=thread -pie"
	["tsan_cxx"]="-fsanitize=thread -fPIE"
	["tsan_env"]="report_signal_unsafe=0:history_size=7:second_deadlock_stack=1:verbosity=1"
	["ubsan_linker"]="-fsanitize=undefined"
	["ubsan_cxx"]="-fsanitize=undefined -fno-omit-frame-pointer"
	["ubsan_env"]="print_stacktrace=1:halt_on_error=1"
)

# Function to display help
show_help() {
	cat <<EOF
Usage: $0 [OPTIONS]

Build Options:
  -b, --build TYPE          Set build type (Debug|RelWithDebInfo|Release|MinSizeRel)
  -d, --build-dir DIR       Set build directory (default: build)
  -i, --install-dir DIR     Set install directory (default: install)
  -s, --sanitizer TYPE      Enable sanitizer (asan|msan|tsan|ubsan)
  -j, --jobs N              Number of parallel build jobs (default: $(nproc 2>/dev/null || echo 4))
  --compiler COMPILER       Use specific compiler (gcc|clang)
  --install-prefix PATH     Set custom install prefix
  -g, --generator GEN       CMake generator (Ninja|Unix Makefiles|Xcode) (default: Ninja)
  -t, --target TARGET       Build specific target(s)

Cross-Compilation:
  --cross TARGET            Cross-compile for target (arm32|aarch64|rpi3|rpi4)
  --toolchain-file FILE     Custom CMake toolchain file
  --sysroot PATH            Sysroot path for cross-compilation

Advanced Build:
  --cmake-args FLAGS        Additional CMake flags (e.g., -DENABLE_FEATURE=ON)
  --cxx-flags FLAGS         Additional C++ compiler flags
  --ccache                  Enable ccache for faster rebuilds
  --coverage                Enable code coverage (implies Debug build)
  --benchmark               Enable benchmark builds with optimizations

Actions:
  --clean                   Clean build artifacts only (no build)
  --test                    Run tests after build (CTest)
  --lint                    Run linters (clang-tidy, cppcheck)
  --install                 Install after building
  --dry-run                 Show build commands without executing
  -v, --verbose             Enable verbose output

Utilities:
  --stats                   Show build statistics
  --list-targets            List available build targets
  --list-cross-targets      List available cross-compilation targets
  -h, --help                Display this help message

Examples:
  # Standard builds
  $0 -b Release
  $0 --build Debug --sanitizer asan --test
  $0 -j 8 --verbose --ccache
  $0 --clean
  $0 --coverage --test
  $0 --cmake-args -DENABLE_TESTS=ON -DBUILD_SHARED_LIBS=ON

  # Cross-compilation
  $0 --cross aarch64 -b Release
  $0 --cross rpi4 --install

  # Building specific targets
  $0 --target my_executable --install
  $0 -t my_lib my_test -j 8

  # Benchmarking
  $0 --benchmark --target benchmark_suite
EOF
	exit 0
}

# Function to list cross-compilation targets
list_cross_targets() {
	log_info "Available cross-compilation targets:"
	echo ""
	echo "  arm32      - ARM 32-bit (ARMv7-A with NEON)"
	echo "  aarch64    - ARM 64-bit (ARMv8-A)"
	echo "  rpi3       - Raspberry Pi 3 (32-bit ARMv8-A)"
	echo "  rpi4       - Raspberry Pi 4 (64-bit ARMv8-A)"
	echo ""
	echo "Usage: $0 --cross <target>"
	exit 0
}

# Function to check if command exists
command_exists() {
	command -v "$1" &>/dev/null
}

# Function to detect generator
detect_generator() {
	if command_exists ninja; then
		echo "Ninja"
	elif command_exists make; then
		echo "Unix Makefiles"
	else
		log_error "No build system found (ninja or make required)"
		exit 1
	fi
}

# Function to create CMake toolchain file
create_toolchain_file() {
	local target="$1"
	local toolchain_file="./${CROSS_TOOLCHAINS[${target}_cmake_file]}"
	local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"
	local arch="${CROSS_TOOLCHAINS[${target}_arch]}"
	local processor="${CROSS_TOOLCHAINS[${target}_processor]}"
	local fpu="${CROSS_TOOLCHAINS[${target}_fpu]:-}"

	log_cross "Creating toolchain file: $toolchain_file"

	cat >"$toolchain_file" <<EOF
# CMake toolchain file for ${target}
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR ${processor})

# Cross-compiler settings
set(CMAKE_C_COMPILER ${toolchain_prefix}-gcc)
set(CMAKE_CXX_COMPILER ${toolchain_prefix}-g++)

# Compiler flags
set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} -march=${arch}" CACHE STRING "" FORCE)
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -march=${arch}" CACHE STRING "" FORCE)

EOF

	if [[ -n "$fpu" ]]; then
		echo "set(CMAKE_C_FLAGS \"\${CMAKE_C_FLAGS} -mfpu=${fpu}\" CACHE STRING \"\" FORCE)" >>"$toolchain_file"
		echo "set(CMAKE_CXX_FLAGS \"\${CMAKE_CXX_FLAGS} -mfpu=${fpu}\" CACHE STRING \"\" FORCE)" >>"$toolchain_file"
	fi

	cat >>"$toolchain_file" <<'EOF'

# Search paths
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
EOF

	echo "$toolchain_file"
}

# Function to verify cross-compilation toolchain
verify_cross_toolchain() {
	local target="$1"
	local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"

	if ! command_exists "${toolchain_prefix}-gcc"; then
		log_error "Cross-compilation toolchain not found: ${toolchain_prefix}-gcc"
		log_info "Install with: sudo apt-get install gcc-${toolchain_prefix} g++-${toolchain_prefix}"
		exit 1
	fi

	log_success "Found cross-compiler: $(${toolchain_prefix}-gcc --version | head -n1)"
}

# Function to setup cross-compilation
setup_cross_compilation() {
	local target="$1"

	# Verify target exists
	if [[ -z "${CROSS_TOOLCHAINS[${target}_toolchain]:-}" ]]; then
		log_error "Unknown cross-compilation target: $target"
		log_info "Use --list-cross-targets to see available targets"
		exit 1
	fi

	log_cross "Setting up cross-compilation for: $target"
	verify_cross_toolchain "$target"

	# Create toolchain file
	local toolchain_file
	toolchain_file=$(create_toolchain_file "$target")

	# Add toolchain file to CMake args
	CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="${PWD}/$toolchain_file")

	log_success "Cross-compilation configured for $target"
}

# Function to setup ccache
setup_ccache() {
	if command_exists ccache; then
		CMAKE_ARGS+=(-DCMAKE_CXX_COMPILER_LAUNCHER=ccache)
		CMAKE_ARGS+=(-DCMAKE_C_COMPILER_LAUNCHER=ccache)
		log_info "ccache enabled"

		# Show ccache stats if verbose
		if [[ "$VERBOSE" == true ]]; then
			ccache -s
		fi
	else
		log_warning "ccache not found, install with: sudo apt install ccache"
		CCACHE_ENABLED=false
	fi
}

# Function to setup compiler
setup_compiler() {
	case "$COMPILER" in
	gcc)
		CMAKE_ARGS+=(-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++)
		log_info "Using GCC compiler"
		;;
	clang)
		CMAKE_ARGS+=(-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++)
		log_info "Using Clang compiler"
		;;
	"")
		# Use default
		;;
	*)
		log_error "Unknown compiler: $COMPILER"
		exit 1
		;;
	esac
}

# Function to normalize build type
normalize_build_type() {
	local input="$1"
	case "${input,,}" in
	debug) echo "Debug" ;;
	release) echo "Release" ;;
	relwithdebinfo) echo "RelWithDebInfo" ;;
	minsizerel) echo "MinSizeRel" ;;
	*)
		log_error "Invalid build type '$input'"
		echo "Valid types: Debug, Release, RelWithDebInfo, MinSizeRel" >&2
		exit 1
		;;
	esac
}

# Function to save build configuration
save_config() {
	{
		echo "PREV_BUILD_TYPE=$BUILD_TYPE"
		echo "PREV_SANITIZER=$SANITIZER"
		echo "PREV_COMPILER=$COMPILER"
		echo "PREV_COVERAGE=$COVERAGE"
		echo "PREV_CROSS_COMPILE=$CROSS_COMPILE"
		echo "PREV_BUILD_DIR=$BUILD_DIR"
	} >"$CONFIG_FILE"
}

# Function to load previous configuration
load_config() {
	[[ ! -f "$CONFIG_FILE" ]] && return 0

	local line var_name var_value
	while IFS= read -r line || [[ -n "$line" ]]; do
		# Skip empty lines and comments
		[[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

		# Parse variable assignment
		if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
			var_name="${BASH_REMATCH[1]}"
			var_value="${BASH_REMATCH[2]}"

			# Remove surrounding quotes if present
			var_value="${var_value%\"}"
			var_value="${var_value#\"}"
			declare -g "$var_name=$var_value"
		fi
	done <"$CONFIG_FILE"
}

# Function to check if rebuild is needed
check_rebuild_needed() {
	local needs_clean=false

	if [[ -n "${PREV_BUILD_TYPE:-}" && "$PREV_BUILD_TYPE" != "$BUILD_TYPE" ]]; then
		log_warning "Build type changed: $PREV_BUILD_TYPE → $BUILD_TYPE"
		needs_clean=true
	fi

	if [[ -n "${PREV_SANITIZER:-}" && "$PREV_SANITIZER" != "$SANITIZER" ]]; then
		log_warning "Sanitizer changed: ${PREV_SANITIZER:-none} → ${SANITIZER:-none}"
		needs_clean=true
	fi

	if [[ -n "${PREV_COMPILER:-}" && "$PREV_COMPILER" != "$COMPILER" ]]; then
		log_warning "Compiler changed: ${PREV_COMPILER:-default} → ${COMPILER:-default}"
		needs_clean=true
	fi

	if [[ -n "${PREV_COVERAGE:-}" && "$PREV_COVERAGE" != "$COVERAGE" ]]; then
		log_warning "Coverage changed: ${PREV_COVERAGE} → ${COVERAGE}"
		needs_clean=true
	fi

	if [[ -n "${PREV_CROSS_COMPILE:-}" && "$PREV_CROSS_COMPILE" != "$CROSS_COMPILE" ]]; then
		log_warning "Cross-compilation target changed: ${PREV_CROSS_COMPILE:-native} → ${CROSS_COMPILE:-native}"
		needs_clean=true
	fi

	if [[ -n "${PREV_BUILD_DIR:-}" && "$PREV_BUILD_DIR" != "$BUILD_DIR" ]]; then
		log_warning "Build directory changed: ${PREV_BUILD_DIR} → ${BUILD_DIR}"
		needs_clean=true
	fi

	if [[ "$needs_clean" == true ]]; then
		log_info "Configuration changed - cleaning build directory..."
		rm -rf "$BUILD_DIR"
	fi
}

# Function to configure sanitizer
configure_sanitizer() {
	local sanitizer="$1"

	log_info "Configuring ${sanitizer^^} (forcing Debug mode)"
	BUILD_TYPE="Debug"

	CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
	CMAKE_ARGS+=(-DCMAKE_SHARED_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
	CMAKE_CXX_FLAGS+=("${SANITIZER_CONFIGS[${sanitizer}_cxx]}")

	cat <<EOF

To enable ${sanitizer^^}, run:
    export ${sanitizer^^}_OPTIONS="${SANITIZER_CONFIGS[${sanitizer}_env]}"

EOF
}

# Function to configure coverage
configure_coverage() {
	log_info "Enabling code coverage (forcing Debug mode)"
	BUILD_TYPE="Debug"
	CMAKE_CXX_FLAGS+=("-fprofile-arcs" "-ftest-coverage" "--coverage")
	CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="--coverage")
	CMAKE_ARGS+=(-DCMAKE_SHARED_LINKER_FLAGS="--coverage")

	cat <<EOF

After running tests, generate coverage report with:
    lcov --capture --directory $BUILD_DIR --output-file coverage.info
    genhtml coverage.info --output-directory coverage_report

EOF
}

# Function to configure build type
configure_build_type() {
	case "$BUILD_TYPE" in
	Release)
		CMAKE_CXX_FLAGS+=("-O3" "-DNDEBUG")

		# Don't use -march=native for cross-compilation
		if [[ -z "$CROSS_COMPILE" && ! "${CMAKE_CXX_FLAGS[*]}" =~ -march= ]]; then
			CMAKE_CXX_FLAGS+=("-march=native")
		fi

		if [[ "$BENCHMARK" == true ]]; then
			CMAKE_CXX_FLAGS+=("-flto" "-ffast-math")
			log_info "Benchmark optimizations enabled (LTO, fast-math)"
		fi
		;;
	Debug)
		CMAKE_CXX_FLAGS+=("-O0" "-g3" "-Wall" "-Wextra" "-Wpedantic")
		CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
		;;
	RelWithDebInfo)
		CMAKE_CXX_FLAGS+=("-O2" "-g3" "-DNDEBUG")
		CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
		;;
	MinSizeRel)
		CMAKE_CXX_FLAGS+=("-Os" "-DNDEBUG")
		;;
	esac
}

# Function to clean build
clean_build() {
	log_info "Cleaning build artifacts..."
	rm -rf "$BUILD_DIR" "$INSTALL_DIR"
	rm -f compile_commands.json "$CONFIG_FILE"

	# Clean cross-compilation toolchain files
	rm -f ./*.cmake 2>/dev/null || true

	log_success "Cleaned all build artifacts"
}

# Function to run tests
run_tests() {
	log_info "Running tests with CTest..."

	if [[ ! -d "$BUILD_DIR" ]]; then
		log_error "Build directory not found. Build first."
		exit 1
	fi

	cd "$BUILD_DIR"
	if [[ "$VERBOSE" == true ]]; then
		ctest --output-on-failure --verbose
	else
		ctest --output-on-failure
	fi
	cd ..
}

# Function to run linters
run_linters() {
	log_info "Running linters..."

	if command_exists clang-tidy && [[ -f "$BUILD_DIR/compile_commands.json" ]]; then
		log_info "Running clang-tidy..."
		find src include -name "*.cpp" -o -name "*.hpp" -o -name "*.h" |
			xargs clang-tidy -p "$BUILD_DIR" 2>&1 | tee clang-tidy.log
	else
		log_warning "clang-tidy not available or compile_commands.json not found"
	fi

	if command_exists cppcheck; then
		log_info "Running cppcheck..."
		cppcheck --enable=all --suppress=missingIncludeSystem \
			--project="$BUILD_DIR/compile_commands.json" \
			2>&1 | tee cppcheck.log
	else
		log_warning "cppcheck not available"
	fi
}

# Generic function to run a command with logging and stream output
run_command() {
	local description="$1" # Description of the task
	shift                  # Remove description from args
	local cmd=("$@")       # Remaining args = the command

	log_info "$description..."

	# Create a temporary file to capture output
	local tmpfile
	tmpfile=$(mktemp)

	# Run the command: stream to terminal and capture in tmpfile
	"${cmd[@]}" 2>&1 | tee "$tmpfile"
	local exit_code=${PIPESTATUS[0]} # capture the exit code of the command

	# Read full output into a variable if needed
	output=$(<"$tmpfile")
	rm -f "$tmpfile"

	if [[ $exit_code -ne 0 ]]; then
		log_error "$description failed"
		log_error "$output" # print full output after failure
		exit 1
	fi

	log_success "$description completed"
}

# Function to list build targets
list_targets() {
	if [[ ! -d "$BUILD_DIR" ]]; then
		log_error "Build directory not found. Configure first with: $0"
		exit 1
	fi

	log_info "Available build targets:"
	cmake --build "$BUILD_DIR" --target help 2>/dev/null || {
		log_warning "Could not list targets. Try building first."
	}
	exit 0
}

# Function to show build statistics
show_stats() {
	log_info "Build Statistics:"

	if [[ -d "$BUILD_DIR" ]]; then
		echo "Build directory size: $(du -sh "$BUILD_DIR" 2>/dev/null | cut -f1)"
		echo "Number of object files: $(find "$BUILD_DIR" -name "*.o" 2>/dev/null | wc -l)"
	fi

	if [[ -d "$INSTALL_DIR" ]]; then
		echo "Install directory size: $(du -sh "$INSTALL_DIR" 2>/dev/null | cut -f1)"
	fi

	if [[ -f "$CONFIG_FILE" ]]; then
		echo ""
		echo "Last build configuration:"
		cat "$CONFIG_FILE"
	fi

	if command_exists ccache; then
		echo ""
		echo "ccache statistics:"
		ccache -s
	fi

	exit 0
}

# Main argument parsing
while [[ $# -gt 0 ]]; do
	case "$1" in
	-b | --build)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "-b requires an argument"
			exit 1
		}
		BUILD_TYPE=$(normalize_build_type "$2")
		shift 2
		;;
	-d | --build-dir)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "-d requires a directory"
			exit 1
		}
		BUILD_DIR="$2"
		shift 2
		;;
	-i | --install-dir)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "-i requires a directory"
			exit 1
		}
		INSTALL_DIR="$2"
		shift 2
		;;
	-s | --sanitizer)
		if [[ -n "${2:-}" && "$2" =~ ^(asan|msan|tsan|ubsan)$ ]]; then
			SANITIZER="$2"
			shift 2
		else
			log_error "-s requires asan, msan, tsan, or ubsan"
			exit 1
		fi
		;;
	-j | --jobs)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "-j requires a number"
			exit 1
		}
		PARALLEL_JOBS="$2"
		shift 2
		;;
	-t | --target)
		shift
		TARGET=""
		while [[ $# -gt 0 && "$1" != -* ]]; do
			TARGET="$TARGET $1"
			shift
		done
		TARGET=$(echo "$TARGET" | xargs) # trim whitespace
		;;
	-g | --generator)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "-g requires a generator name"
			exit 1
		}
		GENERATOR="$2"
		shift 2
		;;
	--compiler)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "--compiler requires gcc or clang"
			exit 1
		}
		COMPILER="$2"
		shift 2
		;;
	--install-prefix)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "--install-prefix requires a path"
			exit 1
		}
		INSTALL_PREFIX="$2"
		shift 2
		;;
	--cross)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "--cross requires a target"
			exit 1
		}
		CROSS_COMPILE="$2"
		shift 2
		;;
	--toolchain-file)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "--toolchain-file requires a path"
			exit 1
		}
		CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="$2")
		shift 2
		;;
	--sysroot)
		[[ -z "${2:-}" || "$2" == -* ]] && {
			log_error "--sysroot requires a path"
			exit 1
		}
		CMAKE_ARGS+=(-DCMAKE_SYSROOT="$2")
		shift 2
		;;
	--cmake-args)
		shift
		while [[ $# -gt 0 && "$1" != --* ]]; do
			CMAKE_ARGS+=("$1")
			shift
		done
		;;
	--cxx-flags)
		shift
		while [[ $# -gt 0 && "$1" != --* ]]; do
			CMAKE_CXX_FLAGS+=("$1")
			shift
		done
		;;
	--ccache)
		CCACHE_ENABLED=true
		shift
		;;
	--coverage)
		COVERAGE=true
		shift
		;;
	--benchmark)
		BENCHMARK=true
		BUILD_TYPE="Release"
		shift
		;;
	--clean)
		CLEAN_ONLY=true
		shift
		;;
	--test)
		RUN_TESTS=true
		CMAKE_ARGS+=(-DBUILD_TESTS=ON)
		shift
		;;
	--lint)
		RUN_LINT=true
		shift
		;;
	--install)
		CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="${INSTALL_DIR}")
		INSTALL_AFTER_BUILD=true
		shift
		;;
	--dry-run)
		DRY_RUN=true
		shift
		;;
	-v | --verbose)
		VERBOSE=true
		shift
		;;
	--stats)
		show_stats
		;;
	--list-targets)
		list_targets
		;;
	--list-cross-targets)
		list_cross_targets
		;;
	-h | --help)
		show_help
		;;
	*)
		log_error "Unknown option '$1'"
		echo "Use -h or --help for usage information" >&2
		exit 1
		;;
	esac
done

# Handle clean-only mode
if [[ "$CLEAN_ONLY" == true ]]; then
	clean_build
	exit 0
fi

# Main execution flow
load_config
check_rebuild_needed

# Detect generator if not explicitly set
if [[ "$GENERATOR" == "Ninja" ]] && ! command_exists ninja; then
	GENERATOR=$(detect_generator)
	log_info "Auto-detected generator: $GENERATOR"
fi

# Setup cross-compilation
if [[ -n "$CROSS_COMPILE" ]]; then
	setup_cross_compilation "$CROSS_COMPILE"
fi

# Setup compiler
[[ -n "$COMPILER" ]] && setup_compiler

# Setup ccache
[[ "$CCACHE_ENABLED" == true ]] && setup_ccache

# Configure coverage
[[ "$COVERAGE" == true ]] && configure_coverage

# Configure sanitizer if requested
[[ -n "$SANITIZER" ]] && configure_sanitizer "$SANITIZER"

# Configure build type
configure_build_type

# Add install prefix if specified
[[ -n "$INSTALL_PREFIX" ]] && CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="$INSTALL_PREFIX")

if [[ $RUN_TESTS == true ]]; then
	TARGET=""
fi

# Finalize CMake arguments
if [[ ${#CMAKE_CXX_FLAGS[@]} -gt 0 ]]; then
	CMAKE_ARGS+=(-DCMAKE_CXX_FLAGS="${CMAKE_CXX_FLAGS[*]}")
fi
CMAKE_ARGS+=(-DCMAKE_BUILD_TYPE="$BUILD_TYPE")

# Display build configuration
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Build Configuration:"
echo "  Type: $BUILD_TYPE"
echo "  Generator: $GENERATOR"
echo "  Build Directory: $BUILD_DIR"
echo "  Install Directory: $INSTALL_DIR"
echo "  Parallel Jobs: $PARALLEL_JOBS"
[[ -n "$COMPILER" ]] && echo "  Compiler: $COMPILER"
[[ -n "$CROSS_COMPILE" ]] && echo "  Cross-Compile: $CROSS_COMPILE"
[[ -n "$SANITIZER" ]] && echo "  Sanitizer: $SANITIZER"
[[ -n "$TARGET" ]] && echo "  Target(s): $TARGET"
[[ "$CCACHE_ENABLED" == true ]] && echo "  ccache: enabled"
[[ "$COVERAGE" == true ]] && echo "  Coverage: enabled"
[[ "$BENCHMARK" == true ]] && echo "  Benchmark: enabled"
[[ "$DRY_RUN" == true ]] && echo "  Mode: DRY RUN"
echo "  CMAKE_ARGS: ${CMAKE_ARGS[*]}"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Show build commands in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
	log_info "CMake configuration command (dry-run):"
	echo "cmake -B $BUILD_DIR -G \"$GENERATOR\" ${CMAKE_ARGS[*]}"
	echo ""
	log_info "Build command (dry-run):"
	if [[ -n "$TARGET" ]]; then
		echo "cmake --build $BUILD_DIR --parallel $PARALLEL_JOBS --target $TARGET"
	else
		echo "cmake --build $BUILD_DIR --parallel $PARALLEL_JOBS"
	fi
	exit 0
fi

# Create build directory if it doesn't exist
mkdir -p "$BUILD_DIR"

# Execute CMake configuration
START_TIME=$(date +%s)

# Prepare cmake command
config_cmd=(cmake -B "$BUILD_DIR" -G "$GENERATOR" "${CMAKE_ARGS[@]}")
[[ "$VERBOSE" == true ]] && config_cmd+=(--debug-output)
run_command "Configuring project with CMake" "${config_cmd[@]}"
log_success "CMake configuration completed"

# Prepare cmake command
build_cmd=(cmake --build "$BUILD_DIR" --parallel "$PARALLEL_JOBS")
[[ -n "$TARGET" ]] && build_cmd+=(--target "$TARGET")
[[ "$VERBOSE" == true ]] && build_cmd+=(--verbose)
run_command "Building project" "${build_cmd[@]}"
log_success "Build completed"

END_TIME=$(date +%s)
BUILD_TIME=$((END_TIME - START_TIME))

# Save configuration
save_config

# Create compile_commands.json symlink for IDE/LSP support
if [[ "$BUILD_TYPE" == "Debug" || "$BUILD_TYPE" == "RelWithDebInfo" ]]; then
	if [[ -f "$BUILD_DIR/compile_commands.json" ]]; then
		if ln -sf "$BUILD_DIR/compile_commands.json" . 2>/dev/null; then
			log_info "Created compile_commands.json symlink for IDE/LSP support"
		fi
	fi
fi

log_success "Build completed successfully in ${BUILD_TIME}s"

# Install if requested
if [[ "${INSTALL_AFTER_BUILD:-false}" == true ]]; then
	log_info "Installing to $INSTALL_DIR..."
	cmake --install "$BUILD_DIR"
	log_success "Installation completed"
fi

# Run tests if requested
[[ "$RUN_TESTS" == true ]] && run_tests

# Run linters if requested
[[ "$RUN_LINT" == true ]] && run_linters

# Show ccache stats at the end if verbose
if [[ "$VERBOSE" == true && "$CCACHE_ENABLED" == true ]]; then
	echo ""
	log_info "Final ccache statistics:"
	ccache -s
fi

# Cross-compilation reminder
if [[ -n "$CROSS_COMPILE" ]]; then
	echo ""
	log_cross "Cross-compilation completed for: $CROSS_COMPILE"
	log_info "Binaries are in: $BUILD_DIR/"
	log_info "Transfer binaries to target device and ensure shared libraries are available"
fi

# Show next steps
echo ""
log_success "Build artifacts are in: $BUILD_DIR/"
if [[ "$RUN_TESTS" != true ]]; then
	log_info "Run tests with: $0 --test"
fi
if [[ "${INSTALL_AFTER_BUILD:-false}" != true ]]; then
	log_info "Install with: $0 --install"
fi
