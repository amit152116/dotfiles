#!/usr/bin/env bash

# Default values
BUILD_TYPE="Debug"
BUILD_DIR="build"
INSTALL_DIR="install"
SANITIZER=""
CONFIG_FILE=".build.config"
VERBOSE=false
DRY_RUN=false
CCACHE_ENABLED=false
CLEAN_ONLY=false
RUN_TESTS=false
RUN_LINT=false
COMPILER=""
INSTALL_PREFIX=""
COVERAGE=false
BENCHMARK=false
TARGET=""
GENERATOR="Ninja"

nproc=$(nproc 2>/dev/null)
PARALLEL_JOBS=$((nproc / 2))
((PARALLEL_JOBS < 4)) && PARALLEL_JOBS=4

# Cross-compilation
CROSS_COMPILE=""

# Pre-allocate arrays for better performance
CMAKE_ARGS=()
CMAKE_CXX_FLAGS=()

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color
GRAY='\e[90m'

# Logging functions
log_info() { echo -e "${BLUE}â„¹${GRAY} $*" >&2; }
log_success() { echo -e "${GREEN}âœ“${NC} $*" >&2; }
log_warning() { echo -e "${YELLOW}âš ${YELLOW} $*" >&2; }
log_error() { echo -e "${RED}âœ—${RED} $*" >&2; }
log_cross() { echo -e "${MAGENTA}ðŸ”§${GRAY} $*" >&2; }

# Cross-compilation toolchain configurations
declare -A CROSS_TOOLCHAINS=(
    # ARM 32-bit
    ["arm32_toolchain"]="arm-linux-gnueabihf"
    ["arm32_cmake_file"]="arm-linux-gnueabihf.cmake"
    ["arm32_arch"]="armv7-a"
    ["arm32_fpu"]="neon-vfpv4"
    ["arm32_processor"]="arm"

    # ARM 64-bit (aarch64)
    ["aarch64_toolchain"]="aarch64-linux-gnu"
    ["aarch64_cmake_file"]="aarch64-linux-gnu.cmake"
    ["aarch64_arch"]="armv8-a"
    ["aarch64_processor"]="aarch64"

    # Raspberry Pi 3/4
    ["rpi3_toolchain"]="arm-linux-gnueabihf"
    ["rpi3_cmake_file"]="rpi3.cmake"
    ["rpi3_arch"]="armv8-a"
    ["rpi3_fpu"]="neon-fp-armv8"
    ["rpi3_processor"]="arm"

    ["rpi4_toolchain"]="aarch64-linux-gnu"
    ["rpi4_cmake_file"]="rpi4.cmake"
    ["rpi4_arch"]="armv8-a"
    ["rpi4_processor"]="aarch64"
)

# Sanitizer configurations (centralized for maintainability)
declare -A SANITIZER_CONFIGS=(
    ["asan_linker"]="-fsanitize=address,undefined,leak"
    ["asan_cxx"]="-fsanitize=address,undefined,leak -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["asan_env"]="new_delete_type_mismatch=0:detect_leaks=1:strict_init_order=1:check_initialization_order=1:symbolize=1:verbosity=1"
    ["msan_linker"]="-fsanitize=memory"
    ["msan_cxx"]="-fsanitize=memory -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["msan_env"]="verbosity=1"
    ["tsan_linker"]="-fsanitize=thread -pie"
    ["tsan_cxx"]="-fsanitize=thread -fPIE"
    ["tsan_env"]="report_signal_unsafe=0:history_size=7:second_deadlock_stack=1:verbosity=1"
    ["ubsan_linker"]="-fsanitize=undefined"
    ["ubsan_cxx"]="-fsanitize=undefined -fno-omit-frame-pointer"
    ["ubsan_env"]="print_stacktrace=1:halt_on_error=1"
)

# Function to display help
show_help() {
    cat <<EOF
Usage: $0 [OPTIONS]

Build Options:
  -b, --build TYPE          Set build type (Debug|RelWithDebInfo|Release|MinSizeRel)
  -d, --build-dir DIR       Set build directory (default: build)
  -i, --install-dir DIR     Set install directory (default: install)
  -s, --sanitizer TYPE      Enable sanitizer (asan|msan|tsan|ubsan)
  -j, --jobs N              Number of parallel build jobs (default: $(nproc 2>/dev/null || echo 4))
  --compiler COMPILER       Use specific compiler (gcc|clang)
  --install-prefix PATH     Set custom install prefix
  -g, --generator GEN       CMake generator (Ninja|Unix Makefiles|Xcode) (default: Ninja)
  -t, --target TARGET       Build specific target(s)

Cross-Compilation:
  --cross TARGET            Cross-compile for target (arm32|aarch64|rpi3|rpi4)
  --toolchain-file FILE     Custom CMake toolchain file
  --sysroot PATH            Sysroot path for cross-compilation

Advanced Build:
  --cmake-args FLAGS        Additional CMake flags (e.g., -DENABLE_FEATURE=ON)
  --cxx-flags FLAGS         Additional C++ compiler flags
  --ccache                  Enable ccache for faster rebuilds
  --coverage                Enable code coverage (implies Debug build)
  --benchmark               Enable benchmark builds with optimizations

Actions:
  --clean                   Clean build artifacts only (no build)
  --test                    Run tests after build (CTest)
  --lint                    Run linters (clang-tidy, cppcheck)
  --install                 Install after building
  --dry-run                 Show build commands without executing
  -v, --verbose             Enable verbose output

Utilities:
  --stats                   Show build statistics
  --list-targets            List available build targets
  --list-cross-targets      List available cross-compilation targets
  -h, --help                Display this help message

Examples:
  # Standard builds
  $0 -b Release
  $0 --build Debug --sanitizer asan --test
  $0 -j 8 --verbose --ccache
  $0 --clean
  $0 --coverage --test
  $0 --cmake-args -DENABLE_TESTS=ON -DBUILD_SHARED_LIBS=ON

  # Cross-compilation
  $0 --cross aarch64 -b Release
  $0 --cross rpi4 --install

  # Building specific targets
  $0 --target my_executable --install
  $0 -t my_lib my_test -j 8

  # Benchmarking
  $0 --benchmark --target benchmark_suite
EOF
    exit 0
}

# Function to list cross-compilation targets
list_cross_targets() {
    log_info "Available cross-compilation targets:"
    echo ""
    echo "  arm32      - ARM 32-bit (ARMv7-A with NEON)"
    echo "  aarch64    - ARM 64-bit (ARMv8-A)"
    echo "  rpi3       - Raspberry Pi 3 (32-bit ARMv8-A)"
    echo "  rpi4       - Raspberry Pi 4 (64-bit ARMv8-A)"
    echo ""
    echo "Usage: $0 --cross <target>"
    exit 0
}

# Function to check if command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Function to detect generator
detect_generator() {
    if command_exists ninja; then
        echo "Ninja"
    elif command_exists make; then
        echo "Unix Makefiles"
    else
        log_error "No build system found (ninja or make required)"
        exit 1
    fi
}

# Function to create CMake toolchain file
create_toolchain_file() {
    local target="$1"
    local toolchain_file="./${CROSS_TOOLCHAINS[${target}_cmake_file]}"
    local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"
    local arch="${CROSS_TOOLCHAINS[${target}_arch]}"
    local processor="${CROSS_TOOLCHAINS[${target}_processor]}"
    local fpu="${CROSS_TOOLCHAINS[${target}_fpu]:-}"

    log_cross "Creating toolchain file: $toolchain_file"

    cat >"$toolchain_file" <<EOF
# CMake toolchain file for ${target}
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR ${processor})

# Cross-compiler settings
set(CMAKE_C_COMPILER ${toolchain_prefix}-gcc)
set(CMAKE_CXX_COMPILER ${toolchain_prefix}-g++)

# Compiler flags
set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} -march=${arch}" CACHE STRING "" FORCE)
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -march=${arch}" CACHE STRING "" FORCE)

EOF

    if [[ -n "$fpu" ]]; then
        echo "set(CMAKE_C_FLAGS \"\${CMAKE_C_FLAGS} -mfpu=${fpu}\" CACHE STRING \"\" FORCE)" >>"$toolchain_file"
        echo "set(CMAKE_CXX_FLAGS \"\${CMAKE_CXX_FLAGS} -mfpu=${fpu}\" CACHE STRING \"\" FORCE)" >>"$toolchain_file"
    fi

    cat >>"$toolchain_file" <<'EOF'

# Search paths
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
EOF

    echo "$toolchain_file"
}

# Function to verify cross-compilation toolchain
verify_cross_toolchain() {
    local target="$1"
    local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"

    if ! command_exists "${toolchain_prefix}-gcc"; then
        log_error "Cross-compilation toolchain not found: ${toolchain_prefix}-gcc"
        log_info "Install with: sudo apt-get install gcc-${toolchain_prefix} g++-${toolchain_prefix}"
        exit 1
    fi

    log_success "Found cross-compiler: $(${toolchain_prefix}-gcc --version | head -n1)"
}

# Function to setup cross-compilation
setup_cross_compilation() {
    local target="$1"

    # Verify target exists
    if [[ -z "${CROSS_TOOLCHAINS[${target}_toolchain]:-}" ]]; then
        log_error "Unknown cross-compilation target: $target"
        log_info "Use --list-cross-targets to see available targets"
        exit 1
    fi

    log_cross "Setting up cross-compilation for: $target"
    verify_cross_toolchain "$target"

    # Create toolchain file
    local toolchain_file
    toolchain_file=$(create_toolchain_file "$target")

    # Add toolchain file to CMake args
    CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="${PWD}/$toolchain_file")

    log_success "Cross-compilation configured for $target"
}

# Function to setup ccache
setup_ccache() {
    if command_exists ccache; then
        CMAKE_ARGS+=(-DCMAKE_CXX_COMPILER_LAUNCHER=ccache)
        CMAKE_ARGS+=(-DCMAKE_C_COMPILER_LAUNCHER=ccache)
        log_info "ccache enabled"

        # Show ccache stats if verbose
        if [[ "$VERBOSE" == true ]]; then
            ccache -s
        fi
    else
        log_warning "ccache not found, install with: sudo apt install ccache"
        CCACHE_ENABLED=false
    fi
}

# Function to setup compiler
setup_compiler() {
    case "$COMPILER" in
        gcc)
            CMAKE_ARGS+=(-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++)
            log_info "Using GCC compiler"
            ;;
        clang)
            CMAKE_ARGS+=(-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++)
            log_info "Using Clang compiler"
            ;;
        "")
            # Use default
            ;;
        *)
            log_error "Unknown compiler: $COMPILER"
            exit 1
            ;;
    esac
}

# Function to normalize build type
normalize_build_type() {
    local input="$1"
    case "${input,,}" in
        debug) echo "Debug" ;;
        release) echo "Release" ;;
        relwithdebinfo) echo "RelWithDebInfo" ;;
        minsizerel) echo "MinSizeRel" ;;
        *)
            log_error "Invalid build type '$input'"
            echo "Valid types: Debug, Release, RelWithDebInfo, MinSizeRel" >&2
            exit 1
            ;;
    esac
}

# Function to save build configuration
save_config() {
    {
        echo "PREV_BUILD_TYPE=$BUILD_TYPE"
        echo "PREV_SANITIZER=$SANITIZER"
        echo "PREV_COMPILER=$COMPILER"
        echo "PREV_COVERAGE=$COVERAGE"
        echo "PREV_CROSS_COMPILE=$CROSS_COMPILE"
        echo "PREV_BUILD_DIR=$BUILD_DIR"
    } >"$CONFIG_FILE"
}

# Function to load previous configuration
load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && return 0

    local line var_name var_value
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse variable assignment
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            var_value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            var_value="${var_value%\"}"
            var_value="${var_value#\"}"
            declare -g "$var_name=$var_value"
        fi
    done <"$CONFIG_FILE"
}

# Function to check if rebuild is needed
check_rebuild_needed() {
    local needs_clean=false

    if [[ -n "${PREV_BUILD_TYPE:-}" && "$PREV_BUILD_TYPE" != "$BUILD_TYPE" ]]; then
        log_warning "Build type changed: $PREV_BUILD_TYPE â†’ $BUILD_TYPE"
        needs_clean=true
    fi

    if [[ -n "${PREV_SANITIZER:-}" && "$PREV_SANITIZER" != "$SANITIZER" ]]; then
        log_warning "Sanitizer changed: ${PREV_SANITIZER:-none} â†’ ${SANITIZER:-none}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COMPILER:-}" && "$PREV_COMPILER" != "$COMPILER" ]]; then
        log_warning "Compiler changed: ${PREV_COMPILER:-default} â†’ ${COMPILER:-default}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COVERAGE:-}" && "$PREV_COVERAGE" != "$COVERAGE" ]]; then
        log_warning "Coverage changed: ${PREV_COVERAGE} â†’ ${COVERAGE}"
        needs_clean=true
    fi

    if [[ -n "${PREV_CROSS_COMPILE:-}" && "$PREV_CROSS_COMPILE" != "$CROSS_COMPILE" ]]; then
        log_warning "Cross-compilation target changed: ${PREV_CROSS_COMPILE:-native} â†’ ${CROSS_COMPILE:-native}"
        needs_clean=true
    fi

    if [[ -n "${PREV_BUILD_DIR:-}" && "$PREV_BUILD_DIR" != "$BUILD_DIR" ]]; then
        log_warning "Build directory changed: ${PREV_BUILD_DIR} â†’ ${BUILD_DIR}"
        needs_clean=true
    fi

    if [[ "$needs_clean" == true ]]; then
        log_info "Configuration changed - cleaning build directory..."
        rm -rf "$BUILD_DIR"
    fi
}

# Function to configure sanitizer
configure_sanitizer() {
    local sanitizer="$1"

    log_info "Configuring ${sanitizer^^} (forcing Debug mode)"
    BUILD_TYPE="Debug"

    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
    CMAKE_ARGS+=(-DCMAKE_SHARED_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
    CMAKE_CXX_FLAGS+=("${SANITIZER_CONFIGS[${sanitizer}_cxx]}")

    cat <<EOF

To enable ${sanitizer^^}, run:
    export ${sanitizer^^}_OPTIONS="${SANITIZER_CONFIGS[${sanitizer}_env]}"

EOF
}

# Function to configure coverage
configure_coverage() {
    log_info "Enabling code coverage (forcing Debug mode)"
    BUILD_TYPE="Debug"
    CMAKE_CXX_FLAGS+=("-fprofile-arcs" "-ftest-coverage" "--coverage")
    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="--coverage")
    CMAKE_ARGS+=(-DCMAKE_SHARED_LINKER_FLAGS="--coverage")

    cat <<EOF

After running tests, generate coverage report with:
    lcov --capture --directory $BUILD_DIR --output-file coverage.info
    genhtml coverage.info --output-directory coverage_report

EOF
}

# Function to configure build type
configure_build_type() {
    case "$BUILD_TYPE" in
        Release)
            CMAKE_CXX_FLAGS+=("-O3" "-DNDEBUG")

            # Don't use -march=native for cross-compilation
            if [[ -z "$CROSS_COMPILE" && ! "${CMAKE_CXX_FLAGS[*]}" =~ -march= ]]; then
                CMAKE_CXX_FLAGS+=("-march=native")
            fi

            if [[ "$BENCHMARK" == true ]]; then
                CMAKE_CXX_FLAGS+=("-flto" "-ffast-math")
                log_info "Benchmark optimizations enabled (LTO, fast-math)"
            fi
            ;;
        Debug)
            CMAKE_CXX_FLAGS+=("-O0" "-g3" "-Wall" "-Wextra" "-Wpedantic")
            CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
            ;;
        RelWithDebInfo)
            CMAKE_CXX_FLAGS+=("-O2" "-g3" "-DNDEBUG")
            CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
            ;;
        MinSizeRel)
            CMAKE_CXX_FLAGS+=("-Os" "-DNDEBUG")
            ;;
    esac
}

# Function to clean build
clean_build() {
    log_info "Cleaning build artifacts..."
    rm -rf "$BUILD_DIR" "$INSTALL_DIR"
    rm -f compile_commands.json "$CONFIG_FILE"

    # Clean cross-compilation toolchain files
    rm -f ./*.cmake 2>/dev/null || true

    log_success "Cleaned all build artifacts"
}

# Function to run tests
run_tests() {
    log_info "Running tests with CTest..."

    if [[ ! -d "$BUILD_DIR" ]]; then
        log_error "Build directory not found. Build first."
        exit 1
    fi

    cd "$BUILD_DIR"
    if [[ "$VERBOSE" == true ]]; then
        ctest --output-on-failure --verbose
    else
        ctest --output-on-failure
    fi
    cd ..
}

# Function to run linters
run_linters() {
    log_info "Running linters..."

    if command_exists clang-tidy && [[ -f "$BUILD_DIR/compile_commands.json" ]]; then
        log_info "Running clang-tidy..."
        find src include -name "*.cpp" -o -name "*.hpp" -o -name "*.h" |
        xargs clang-tidy -p "$BUILD_DIR" 2>&1 | tee clang-tidy.log
    else
        log_warning "clang-tidy not available or compile_commands.json not found"
    fi

    if command_exists cppcheck; then
        log_info "Running cppcheck..."
        cppcheck --enable=all --suppress=missingIncludeSystem \
            --project="$BUILD_DIR/compile_commands.json" \
            2>&1 | tee cppcheck.log
    else
        log_warning "cppcheck not available"
    fi
}

# Generic function to run a command with logging and stream output
run_command() {
    local description="$1" # Description of the task
    shift                  # Remove description from args
    local cmd=("$@")       # Remaining args = the command

    log_info "$description..."

    # Create a temporary file to capture output
    local tmpfile
    tmpfile=$(mktemp)

    # Run the command: stream to terminal and capture in tmpfile
    "${cmd[@]}" 2>&1 | tee "$tmpfile"
    local exit_code=${PIPESTATUS[0]} # capture the exit code of the command

    # Read full output into a variable if needed
    output=$(<"$tmpfile")
    rm -f "$tmpfile"

    if [[ $exit_code -ne 0 ]]; then
        log_error "$description failed"
        log_error "$output" # print full output after failure
        exit 1
    fi

    log_success "$description completed"
}

# Function to list build targets
list_targets() {
    if [[ ! -d "$BUILD_DIR" ]]; then
        log_error "Build directory not found. Configure first with: $0"
        exit 1
    fi

    log_info "Available build targets:"
    cmake --build "$BUILD_DIR" --target help 2>/dev/null || {
        log_warning "Could not list targets. Try building first."
    }
    exit 0
}

# Function to show build statistics
show_stats() {
    log_info "Build Statistics:"

    if [[ -d "$BUILD_DIR" ]]; then
        echo "Build directory size: $(du -sh "$BUILD_DIR" 2>/dev/null | cut -f1)"
        echo "Number of object files: $(find "$BUILD_DIR" -name "*.o" 2>/dev/null | wc -l)"
    fi

    if [[ -d "$INSTALL_DIR" ]]; then
        echo "Install directory size: $(du -sh "$INSTALL_DIR" 2>/dev/null | cut -f1)"
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        echo ""
        echo "Last build configuration:"
        cat "$CONFIG_FILE"
    fi

    if command_exists ccache; then
        echo ""
        echo "ccache statistics:"
        ccache -s
    fi

    exit 0
}

# Main argument parsing
while [[ $# -gt 0 ]]; do
    case "$1" in
        -b | --build)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-b requires an argument"
                exit 1
            }
            BUILD_TYPE=$(normalize_build_type "$2")
            shift 2
            ;;
        -d | --build-dir)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-d requires a directory"
                exit 1
            }
            BUILD_DIR="$2"
            shift 2
            ;;
        -i | --install-dir)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-i requires a directory"
                exit 1
            }
            INSTALL_DIR="$2"
            shift 2
            ;;
        -s | --sanitizer)
            if [[ -n "${2:-}" && "$2" =~ ^(asan|msan|tsan|ubsan)$ ]]; then
                SANITIZER="$2"
                shift 2
            else
                log_error "-s requires asan, msan, tsan, or ubsan"
                exit 1
            fi
            ;;
        -j | --jobs)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-j requires a number"
                exit 1
            }
            PARALLEL_JOBS="$2"
            shift 2
            ;;
        -t | --target)
            shift
            TARGET=""
            while [[ $# -gt 0 && "$1" != -* ]]; do
                TARGET="$TARGET $1"
                shift
            done
            TARGET=$(echo "$TARGET" | xargs) # trim whitespace
            ;;
        -g | --generator)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-g requires a generator name"
                exit 1
            }
            GENERATOR="$2"
            shift 2
            ;;
        --compiler)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--compiler requires gcc or clang"
                exit 1
            }
            COMPILER="$2"
            shift 2
            ;;
        --install-prefix)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--install-prefix requires a path"
                exit 1
            }
            INSTALL_PREFIX="$2"
            shift 2
            ;;
        --cross)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--cross requires a target"
                exit 1
            }
            CROSS_COMPILE="$2"
            shift 2
            ;;
        --toolchain-file)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--toolchain-file requires a path"
                exit 1
            }
            CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="$2")
            shift 2
            ;;
        --sysroot)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--sysroot requires a path"
                exit 1
            }
            CMAKE_ARGS+=(-DCMAKE_SYSROOT="$2")
            shift 2
            ;;
        --cmake-args)
            shift
            while [[ $# -gt 0 && "$1" != --* ]]; do
                CMAKE_ARGS+=("$1")
                shift
            done
            ;;
        --cxx-flags)
            shift
            while [[ $# -gt 0 && "$1" != --* ]]; do
                CMAKE_CXX_FLAGS+=("$1")
                shift
            done
            ;;
        --ccache)
            CCACHE_ENABLED=true
            shift
            ;;
        --coverage)
            COVERAGE=true
            shift
            ;;
        --benchmark)
            BENCHMARK=true
            BUILD_TYPE="Release"
            shift
            ;;
        --clean)
            CLEAN_ONLY=true
            shift
            ;;
        --test)
            RUN_TESTS=true
            CMAKE_ARGS+=(-DBUILD_TESTS=ON)
            shift
            ;;
        --lint)
            RUN_LINT=true
            shift
            ;;
        --install)
            CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="${INSTALL_DIR}")
            INSTALL_AFTER_BUILD=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        --stats)
            show_stats
            ;;
        --list-targets)
            list_targets
            ;;
        --list-cross-targets)
            list_cross_targets
            ;;
        -h | --help)
            show_help
            ;;
        *)
            log_error "Unknown option '$1'"
            echo "Use -h or --help for usage information" >&2
            exit 1
            ;;
    esac
done

# Handle clean-only mode
if [[ "$CLEAN_ONLY" == true ]]; then
    clean_build
    exit 0
fi

# Main execution flow
load_config
check_rebuild_needed

# Detect generator if not explicitly set
if [[ "$GENERATOR" == "Ninja" ]] && ! command_exists ninja; then
    GENERATOR=$(detect_generator)
    log_info "Auto-detected generator: $GENERATOR"
fi

# Setup cross-compilation
if [[ -n "$CROSS_COMPILE" ]]; then
    setup_cross_compilation "$CROSS_COMPILE"
fi

# Setup compiler
[[ -n "$COMPILER" ]] && setup_compiler

# Setup ccache
[[ "$CCACHE_ENABLED" == true ]] && setup_ccache

# Configure coverage
[[ "$COVERAGE" == true ]] && configure_coverage

# Configure sanitizer if requested
[[ -n "$SANITIZER" ]] && configure_sanitizer "$SANITIZER"

# Configure build type
configure_build_type

# Add install prefix if specified
[[ -n "$INSTALL_PREFIX" ]] && CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="$INSTALL_PREFIX")

if [[ $RUN_TESTS == true ]]; then
    TARGET=""
fi

# Finalize CMake arguments
if [[ ${#CMAKE_CXX_FLAGS[@]} -gt 0 ]]; then
    CMAKE_ARGS+=(-DCMAKE_CXX_FLAGS="${CMAKE_CXX_FLAGS[*]}")
fi
CMAKE_ARGS+=(-DCMAKE_BUILD_TYPE="$BUILD_TYPE")

# Display build configuration
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "Build Configuration:"
echo "  Type: $BUILD_TYPE"
echo "  Generator: $GENERATOR"
echo "  Build Directory: $BUILD_DIR"
echo "  Install Directory: $INSTALL_DIR"
echo "  Parallel Jobs: $PARALLEL_JOBS"
[[ -n "$COMPILER" ]] && echo "  Compiler: $COMPILER"
[[ -n "$CROSS_COMPILE" ]] && echo "  Cross-Compile: $CROSS_COMPILE"
[[ -n "$SANITIZER" ]] && echo "  Sanitizer: $SANITIZER"
[[ -n "$TARGET" ]] && echo "  Target(s): $TARGET"
[[ "$CCACHE_ENABLED" == true ]] && echo "  ccache: enabled"
[[ "$COVERAGE" == true ]] && echo "  Coverage: enabled"
[[ "$BENCHMARK" == true ]] && echo "  Benchmark: enabled"
[[ "$DRY_RUN" == true ]] && echo "  Mode: DRY RUN"
echo "  CMAKE_ARGS: ${CMAKE_ARGS[*]}"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Show build commands in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
    log_info "CMake configuration command (dry-run):"
    echo "cmake -B $BUILD_DIR -G \"$GENERATOR\" ${CMAKE_ARGS[*]}"
    echo ""
    log_info "Build command (dry-run):"
    if [[ -n "$TARGET" ]]; then
        echo "cmake --build $BUILD_DIR --parallel $PARALLEL_JOBS --target $TARGET"
    else
        echo "cmake --build $BUILD_DIR --parallel $PARALLEL_JOBS"
    fi
    exit 0
fi

# Create build directory if it doesn't exist
mkdir -p "$BUILD_DIR"

# Execute CMake configuration
START_TIME=$(date +%s)

# Prepare cmake command
config_cmd=(cmake -B "$BUILD_DIR" -G "$GENERATOR" "${CMAKE_ARGS[@]}")
[[ "$VERBOSE" == true ]] && config_cmd+=(--debug-output)
run_command "Configuring project with CMake" "${config_cmd[@]}"
log_success "CMake configuration completed"

# Prepare cmake command
build_cmd=(cmake --build "$BUILD_DIR" --parallel "$PARALLEL_JOBS")
[[ -n "$TARGET" ]] && build_cmd+=(--target "$TARGET")
[[ "$VERBOSE" == true ]] && build_cmd+=(--verbose)
run_command "Building project" "${build_cmd[@]}"
log_success "Build completed"

END_TIME=$(date +%s)
BUILD_TIME=$((END_TIME - START_TIME))

# Save configuration
save_config

# Create compile_commands.json symlink for IDE/LSP support
if [[ "$BUILD_TYPE" == "Debug" || "$BUILD_TYPE" == "RelWithDebInfo" ]]; then
    if [[ -f "$BUILD_DIR/compile_commands.json" ]]; then
        if ln -sf "$BUILD_DIR/compile_commands.json" . 2>/dev/null; then
            log_info "Created compile_commands.json symlink for IDE/LSP support"
        fi
    fi
fi

log_success "Build completed successfully in ${BUILD_TIME}s"

# Install if requested
if [[ "${INSTALL_AFTER_BUILD:-false}" == true ]]; then
    log_info "Installing to $INSTALL_DIR..."
    cmake --install "$BUILD_DIR"
    log_success "Installation completed"
fi

# Run tests if requested
[[ "$RUN_TESTS" == true ]] && run_tests

# Run linters if requested
[[ "$RUN_LINT" == true ]] && run_linters

# Show ccache stats at the end if verbose
if [[ "$VERBOSE" == true && "$CCACHE_ENABLED" == true ]]; then
    echo ""
    log_info "Final ccache statistics:"
    ccache -s
fi

# Cross-compilation reminder
if [[ -n "$CROSS_COMPILE" ]]; then
    echo ""
    log_cross "Cross-compilation completed for: $CROSS_COMPILE"
    log_info "Binaries are in: $BUILD_DIR/"
    log_info "Transfer binaries to target device and ensure shared libraries are available"
fi

# Show next steps
echo ""
log_success "Build artifacts are in: $BUILD_DIR/"
if [[ "$RUN_TESTS" != true ]]; then
    log_info "Run tests with: $0 --test"
fi
if [[ "${INSTALL_AFTER_BUILD:-false}" != true ]]; then
    log_info "Install with: $0 --install"
fi
