#!/usr/bin/env bash

#==============================================================================
# tmux-sessionizer - A fuzzy finder for tmux sessions and project directories
#==============================================================================

VERSION="0.1.0"

#------------------------------------------------------------------------------
# Configuration & Paths
#------------------------------------------------------------------------------

CONFIG_FILE_NAME="tmux-sessionizer.conf"
CONFIG_DIR="$HOME/.dotfiles/scripts"
CONFIG_FILE="$CONFIG_DIR/$CONFIG_FILE_NAME"
PANE_CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/tmux-sessionizer"
PANE_CACHE_FILE="$PANE_CACHE_DIR/panes.cache"

[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

#------------------------------------------------------------------------------
# Logging Function
#------------------------------------------------------------------------------

TS_LOG_FILE="${TS_LOG_FILE:-$HOME/.local/share/tmux-sessionizer/tmux-sessionizer.logs}"

log() {
    case "$TS_LOG" in
    "echo") echo "$*" ;;
    "file") mkdir -p "$(dirname "$TS_LOG_FILE")" && echo "$(date '+%Y-%m-%d %H:%M:%S') $*" >>"$TS_LOG_FILE" ;;
    esac
}

#------------------------------------------------------------------------------
# Global Variables
#------------------------------------------------------------------------------

session_idx=""
session_cmd=""
split_type=""
session_args=""
user_selected=""
_TS_FZF_ONLY=""

#------------------------------------------------------------------------------
# Help & Version Functions
#------------------------------------------------------------------------------

show_help() {
    cat <<EOF
Usage: tmux-sessionizer [OPTIONS] [SEARCH_PATH]

Options:
  -h, --help             Display this help message
  -v, --version          Display version information
  -c, --cmd <name>       Session command name
      -- <args>          Session command arguments
      --vsplit           Create vertical split (horizontal layout) for session command
      --hsplit           Create horizontal split (vertical layout) for session command

Examples:
  tmux-sessionizer                              # Open fuzzy finder
  tmux-sessionizer -c help-fzf                  # Run session command at index 0
  tmux-sessionizer -c btop -- ~/myrepo          # Run session command 2 with args
  tmux-sessionizer -c lazygit --hsplit          # Run with multiple args in hsplit
  tmux-sessionizer ~/projects                   # Open specific directory
EOF
}

show_version() {
    echo "tmux-sessionizer version $VERSION"
}

#------------------------------------------------------------------------------
# Argument Parsing
#------------------------------------------------------------------------------

parse_arguments() {
    while [[ "$#" -gt 0 ]]; do
        case "$1" in
        --)
            shift
            session_args="$*"
            break
            ;;
        -h | --help)
            show_help
            exit 0
            ;;
        -v | --version)
            show_version
            exit 0
            ;;
        -c | --cmd)
            if [[ -z "$2" || "$2" == -* ]]; then
                echo "Error: --cmd requires a value" >&2
                exit 1
            fi
            session_cmd="$2"
            shift
            ;;
        --vsplit)
            split_type="vsplit"
            ;;
        --hsplit)
            split_type="hsplit"
            ;;
        --_fzf-only)
            _TS_FZF_ONLY=1
            ;;
        *)
            user_selected="$1"
            ;;
        esac
        shift
    done

    # Handle session command index resolution
    if [[ -n "$session_cmd" ]]; then
        # Try to find session_cmd in TS_SESSION_COMMANDS array
        local found_idx=""
        for i in "${!TS_SESSION_COMMANDS[@]}"; do
            if [[ "${TS_SESSION_COMMANDS[$i]}" == "$session_cmd" ]]; then
                found_idx="$i"
                break
            fi
        done

        if [[ -n "$found_idx" ]]; then
            # Found in array: use offset TS_OFFSET_IDX + array index
            session_idx=$((TS_SESSION_BASE + found_idx))
        else
            # Not found: use hash-based index (range 50-149)
            # session_idx=$((TS_HASHED_SESSION_IDX + $(echo -n "$session_cmd" | cksum | cut -d' ' -f1) % TS_HASHED_SESSION_RANGE))

            session_idx=$((TS_HASHED_SESSION_BASE + $(ts_hash "$session_cmd") % TS_HASHED_SESSION_RANGE))
        fi
        # elif [[ -n "$session_idx" ]]; then
        #     # Using -s flag: validate and resolve from array
        #     if [[ -z "${TS_SESSION_COMMANDS[*]}" ]]; then
        #         echo "Error: TS_SESSION_COMMANDS is not set" >&2
        #         echo "Must have a command set to run when switching to a session" >&2
        #         exit 1
        #     fi
        #
        #     if [[ -z "$session_idx" ]] || ((session_idx < 0 || session_idx >= ${#TS_SESSION_COMMANDS[@]})); then
        #         echo "Error: Invalid index. Please provide an index between 0 and $((${#TS_SESSION_COMMANDS[@]} - 1))." >&2
        #         exit 1
        #     fi
        #
        #     session_cmd="${TS_SESSION_COMMANDS[$session_idx]}"
        #     session_idx=$((TS_SESSION_BASE + session_idx))
    fi

    # Validate split options are only used with session commands
    if [[ -n "$split_type" && -z "$session_cmd" ]]; then
        echo "Error: --vsplit and --hsplit can only be used with -s/--session or -c/--cmd option" >&2
        exit 1
    fi

    log "tmux-sessionizer($VERSION): idx=$session_idx cmd=$session_cmd args='$session_args' split_type=$split_type log=$TS_LOG log_file=$TS_LOG_FILE"
}

#------------------------------------------------------------------------------
# Sanity Checks
#------------------------------------------------------------------------------

sanity_check() {
    if ! command -v tmux &>/dev/null; then
        echo "Error: tmux is not installed. Please install it first." >&2
        exit 1
    fi

    if ! command -v fzf &>/dev/null; then
        echo "Error: fzf is not installed. Please install it first." >&2
        exit 1
    fi
}

#------------------------------------------------------------------------------
# Tmux Helper Functions
#------------------------------------------------------------------------------

is_tmux_running() {
    local tmux_running
    tmux_running=$(pgrep tmux)

    if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
        return 1
    fi
    return 0
}

has_session() {
    tmux list-sessions 2>/dev/null | grep -q "^$1:"
}

tmux_popup() {
    tmux neww -t 404 -n popup -- bash -c "
    clear
    echo \"$1\"
    echo
    echo 'Press any key to close'
    read -n1
  "
}

ts_hash() {
    local s="$1"
    local h=0
    local i c
    for ((i = 0; i < ${#s}; i++)); do
        printf -v c '%d' "'${s:i:1}"
        ((h = (h * 31 + c) & 0x7fffffff))
    done
    echo "$h"
}

switch_to() {
    if [[ -z $TMUX ]]; then
        log "Attaching to session $1"
        tmux attach-session -t "$1"
    else
        log "Switching to session $1"
        tmux switch-client -t "$1"
    fi
}

hydrate() {
    local session_name="$1"
    local selected_path="$2"

    if [[ -n $session_cmd ]]; then
        log "Skipping hydrate for $session_name -- using \"$session_cmd\" instead"
        return
    elif [[ -f "$selected_path/.tmux-sessionizer" ]]; then
        log "Sourcing (local) $selected_path/.tmux-sessionizer"
        tmux send-keys -t "$session_name" "source $selected_path/.tmux-sessionizer" C-m
    elif [[ -f "$HOME/.tmux-sessionizer" ]]; then
        log "Sourcing (global) $HOME/.tmux-sessionizer"
        tmux send-keys -t "$session_name" "source $HOME/.tmux-sessionizer" C-m
    fi
}

#------------------------------------------------------------------------------
# Pane Cache Management
#------------------------------------------------------------------------------

init_pane_cache() {
    mkdir -p "$PANE_CACHE_DIR"
    touch "$PANE_CACHE_FILE"
}

get_pane_id() {
    local session_idx="$1"
    local split_type="$2"
    init_pane_cache
    grep "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" 2>/dev/null | cut -d: -f3
}

set_pane_id() {
    local session_idx="$1"
    local split_type="$2"
    local pane_id="$3"
    init_pane_cache

    # Remove existing entry if it exists
    grep -v "^${session_idx}:${split_type}:" "$PANE_CACHE_FILE" >"${PANE_CACHE_FILE}.tmp" 2>/dev/null || true
    mv "${PANE_CACHE_FILE}.tmp" "$PANE_CACHE_FILE"

    # Add new entry
    echo "${session_idx}:${split_type}:${pane_id}" >>"$PANE_CACHE_FILE"
}

cleanup_dead_panes() {
    init_pane_cache
    local temp_file="${PANE_CACHE_FILE}.tmp"

    while IFS=: read -r idx split pane_id; do
        if tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${pane_id}$"; then
            echo "${idx}:${split}:${pane_id}" >>"$temp_file"
        fi
    done <"$PANE_CACHE_FILE"

    mv "$temp_file" "$PANE_CACHE_FILE" 2>/dev/null || touch "$PANE_CACHE_FILE"
}

#------------------------------------------------------------------------------
# Directory Search Function
#------------------------------------------------------------------------------

find_dirs() {
    # 1ï¸âƒ£ Get list of existing tmux session directories
    local -A tmux_dirs
    if command -v tmux >/dev/null 2>&1; then
        while IFS= read -r session_dir; do
            [[ -n "$session_dir" ]] && tmux_dirs["$session_dir"]=1
        done < <(tmux list-sessions -F "#{session_path}" 2>/dev/null)
    fi

    # List TMUX sessions (if inside tmux)
    if [[ -n "${TMUX}" ]]; then
        local current_session
        current_session=$(tmux display-message -p '#S')

        # 1. List timestamps and names separated by ':'
        # 2. Sort numerically descending (-nr) by the first field (timestamp)
        # 3. Filter out the current session
        # 4. Remove the timestamp to show only the name
        tmux list-sessions -F "#{session_last_attached}|[TMUX] #{session_name}" 2>/dev/null |
            sort -t'|' -k1,1nr |
            sed "s/^[^|]*|//" |
            grep -vFx "[TMUX] $current_session"
    fi

    # 2ï¸âƒ£ Search configured paths
    for entry in "${TS_SEARCH_PATHS[@]}"; do
        local path="${entry%%:*}"
        local depth="${entry##*:}"
        [[ "$depth" == "$entry" ]] && depth="${TS_MAX_DEPTH:-1}"

        [[ -d "$path" ]] || continue

        find "$path" -mindepth 1 -maxdepth "$depth" -type d -print0 | while IFS= read -r -d '' dir; do

            [[ "$(basename "$dir")" == .* ]] && continue

            # Transform the path to use ~
            # This replaces the literal value of $HOME at the start of the string with ~
            local display_path="${dir/#$HOME/\~}"

            # Check if it's a git repository (bare or normal)
            if git -C "$dir" rev-parse --git-dir >/dev/null 2>&1; then
                local git_dir
                git_dir=$(git -C "$dir" rev-parse --git-dir 2>/dev/null)

                # Check if it's a bare repository
                if [[ "$git_dir" == "." ]]; then
                    # Bare repo - list all worktrees
                    git -C "$dir" worktree list --porcelain | awk '
                        /^worktree / { path = substr($0, 10); next }
                        /^branch / { 
                            branch = substr($0, 8)
                            sub(/^refs\/heads\//, "", branch)
                            if (path) { printf "%s [%s]\n", path, branch; path = "" }
                        }
                    ' | while IFS= read -r worktree_line; do
                        # Extract worktree path and check if it has a session
                        local wt_path="${worktree_line%% \[*}"
                        [[ -z "${tmux_dirs[$wt_path]}" ]] && echo "${worktree_line/#$HOME/\~}"
                    done
                else
                    # Skip if directory already has a tmux session
                    [[ -n "${tmux_dirs[$dir]}" ]] && continue

                    # Normal repo - show current branch
                    local branch
                    branch=$(git -C "$dir" symbolic-ref --short HEAD 2>/dev/null ||
                        git -C "$dir" rev-parse --short HEAD 2>/dev/null)
                    if [[ -n "$branch" ]]; then
                        printf '%s [%s]\n' "$display_path" "$branch"
                    else
                        printf '%s\n' "$display_path"
                    fi
                fi
            else
                # Skip if directory already has a tmux session
                [[ -n "${tmux_dirs[$dir]}" ]] && continue

                # Not a git repository
                printf '%s\n' "$display_path"
            fi
        done
    done
}

#------------------------------------------------------------------------------
# Session Command Handlers
#------------------------------------------------------------------------------

handle_window_session_cmd() {
    local current_session="$1"

    local target="$current_session:$session_idx"

    # Build the full command with args if provided
    local full_cmd="$session_cmd"
    if [[ -n "$session_args" ]]; then
        full_cmd="$session_cmd $session_args"
    fi

    log "Target: $target, Command: $full_cmd"

    if tmux has-session -t="$target" 2>/dev/null; then
        switch_to "$target"
    else
        log "Creating new window: tmux neww -dt $target $full_cmd"
        tmux neww -dt "$target" "$full_cmd"
        tmux rename-window -t "$target" "$session_cmd"
        hydrate "$target" "$selected"
        error=$(tmux select-window -t "$target" 2>&1 >/dev/null)

        if [[ -n $error ]]; then
            log "Error: Failed to open window: $error" >&2
            tmux_popup "âš ï¸Error: Failed to open window: $error"

        fi
    fi
}

handle_split_session_cmd() {
    local current_session="$1"
    cleanup_dead_panes

    # Build the full command with args if provided
    local full_cmd="$session_cmd"
    if [[ -n "$session_args" ]]; then
        full_cmd="$session_cmd $session_args"
    fi

    # Check if pane already exists
    local existing_pane_id
    existing_pane_id=$(get_pane_id "$session_idx" "$split_type")

    if [[ -n "$existing_pane_id" ]] && tmux list-panes -a -F "#{pane_id}" 2>/dev/null | grep -q "^${existing_pane_id}$"; then
        log "Switching to existing pane $existing_pane_id"
        tmux select-pane -t "$existing_pane_id"
        if [[ -z $TMUX ]]; then
            tmux attach-session -t "$current_session"
        else
            tmux switch-client -t "$current_session"
        fi
    else
        # Create new split
        local split_flag
        if [[ "$split_type" == "vsplit" ]]; then
            split_flag="-h" # Horizontal layout (vertical split)
        else
            split_flag="-v" # Vertical layout (horizontal split)
        fi

        log "Creating new split: tmux split-window $split_flag -c $(pwd) $full_cmd"
        local new_pane_id
        new_pane_id=$(tmux split-window "$split_flag" -c "$(pwd)" -P -F "#{pane_id}" "$full_cmd")

        if [[ -n "$new_pane_id" ]]; then
            set_pane_id "$session_idx" "$split_type" "$new_pane_id"
            log "Created pane $new_pane_id for session_idx=$session_idx split_type=$split_type"
        fi
    fi
}

handle_session_cmd() {
    log "Executing session command: $session_cmd (index: $session_idx, args: '$session_args', split: $split_type)"

    if ! is_tmux_running; then
        echo "Error: tmux is not running. Please start tmux first before using session commands." >&2
        exit 1
    fi

    if ! command -v $session_cmd &>/dev/null; then
        echo "Error: Session command '$session_cmd' is not installed." >&2
        exit 1
    fi

    local current_session
    current_session=$(tmux display-message -p '#S')

    if [[ -n "$split_type" ]]; then
        handle_split_session_cmd "$current_session"
    else
        handle_window_session_cmd "$current_session"
    fi
    exit 0
}

#------------------------------------------------------------------------------
# Fuzzy Finder
#------------------------------------------------------------------------------

run_fuzzy_finder() {
    # When running inside the popup (subshell), DIRS_CACHE and RESULT_FILE are set
    # by the parent; just run fzf and write the selection to RESULT_FILE.
    if [[ -n "${_TS_DIRS_CACHE:-}" && -n "${_TS_RESULT_FILE:-}" ]]; then
        FZF_DEFAULT_OPTS="\
            --tiebreak=index \
            --preview '
                if [[ {} == \[TMUX\]* ]]; then
                    session=\$(echo {} | sed \"s/^\\\[TMUX\\\] //\" | sed \"s/ \\\[.*\\\]$//\")
                    branch=\$(echo {} | grep -oP \"\\\[\\K[^\\\]]+(?=\\\]$)\" || echo \"\")
                    {
                        echo \"ğŸ–¥ï¸  Session: \$session\"
                        [[ -n \"\$branch\" ]] && echo \"ğŸŒ¿ Branch: \$branch\"
                        echo \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\"
                        echo \"Windows:\"
                        tmux list-windows -t \"\$session\" -F \"#I: #W #{?window_active,â˜…, }\"
                        echo
                        echo \"Panes:\"
                        tmux list-panes -t \"\$session\" -F \"#I.#P: #{pane_current_command} (#{pane_width}x#{pane_height})\"
                    } 2>/dev/null | batcat -l yaml --color=always -p
                elif [[ {} =~ ^(.+)\ \\\[([^\\\]]+)\\\]$ ]]; then
                    dir=\"\${BASH_REMATCH[1]}\"
                    branch=\"\${BASH_REMATCH[2]}\"
                    if [[ -d \"\$dir\" ]]; then
                        {
                            echo \"ğŸ“ Directory: \$dir\"
                            echo \"ğŸŒ¿ Branch: \$branch\"
                            echo \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\"
                            echo
                        } | batcat -l yaml --color=always -p
                        eza -1 --icons --color=always --group-directories-first \"\$dir\"
                    fi
                elif [[ -d {} ]]; then
                    {
                        echo \"ğŸ“ Directory: {}\"
                        echo \"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\"
                        echo
                    } | batcat -l yaml --color=always -p
                    eza -1 --icons --color=always --group-directories-first {}
                else
                    echo \"Not a directory or tmux session\"
                fi
            ' \
            --prompt='â¯ ' \
            --pointer='â¤ ' \
            --marker='âœ“ ' \
            --color=marker:#98c379,fg+:#abb2bf,prompt:#61afef,hl+:#e06c75 \
            --bind 'ctrl-v:toggle-preview' \
            --header 'â†µ:open  ctrl-v:toggle preview' \
        " fzf <"$_TS_DIRS_CACHE" >"$_TS_RESULT_FILE"
        return
    fi

    # Parent path: cache dirs, open a popup that re-invokes this script in
    # "fzf-only" mode, then read back the selection.
    local dirs_cache result_file
    dirs_cache=$(mktemp)
    result_file=$(mktemp)
    find_dirs >"$dirs_cache"

    export _TS_DIRS_CACHE="$dirs_cache"
    export _TS_RESULT_FILE="$result_file"

    tmux display-popup -E -w 70% -h 70% \
        "bash -c '_TS_DIRS_CACHE=${dirs_cache} _TS_RESULT_FILE=${result_file} ${0} --_fzf-only'"

    local result
    result=$(cat "$result_file")
    rm -f "$dirs_cache" "$result_file"
    unset _TS_DIRS_CACHE _TS_RESULT_FILE
    echo "$result"
}

is_worktree() {
    local dir_path="$1"
    local parent_dir=$(dirname "$dir_path")
    [[ -d "$parent_dir" ]] &&
        [[ "$(git -C "$parent_dir" rev-parse --is-bare-repository 2>/dev/null)" == "true" ]]
}

#------------------------------------------------------------------------------
# Main Execution Logic
#------------------------------------------------------------------------------
main() {
    sanity_check
    parse_arguments "$@"

    # Popup re-invocation: just run fzf and exit
    if [[ -n "$_TS_FZF_ONLY" ]]; then
        run_fuzzy_finder
        return
    fi

    # Handle session command if specified
    if [[ -n $session_cmd ]]; then
        handle_session_cmd
        return
    fi

    # Set default search paths if not configured
    [[ -n "$TS_SEARCH_PATHS" ]] || TS_SEARCH_PATHS=(~/)

    # Add extra search paths if configured
    if [[ ${#TS_EXTRA_SEARCH_PATHS[@]} -gt 0 ]]; then
        TS_SEARCH_PATHS+=("${TS_EXTRA_SEARCH_PATHS[@]}")
    fi

    local raw_input
    local selected_path
    local selected_name

    # 1. Determine Input Source
    if [[ -n "$user_selected" ]]; then
        # Validation: Check if empty OR if NOT (!) a directory
        if [[ -z "$user_selected" ]] || [[ ! -d "$user_selected" ]]; then
            echo "Error: Invalid selection (empty or not a directory)" >&2
            exit 1
        fi
        raw_input="$user_selected"
    else
        raw_input=$(run_fuzzy_finder)
        [[ -z "$raw_input" ]] && exit 0
    fi

    # 2. Handle Existing TMUX Sessions (Early Exit)
    # If the selection is an existing session from the list, just switch to it.
    if [[ "$raw_input" =~ ^\[TMUX\]\ (.+)$ ]]; then
        switch_to "${BASH_REMATCH[1]}"
        return
    fi

    # 3. Extract Path from Input
    # Regex matches: "Path [Branch]" OR just "Path"
    if [[ "$raw_input" =~ ^(.+)\ \[([^\]]+)\]$ ]]; then
        selected_path="${BASH_REMATCH[1]}"
    else
        selected_path="$raw_input"
    fi

    # Expand tilde (~) to $HOME safely
    selected_path="${selected_path/#\~/$HOME}"

    # 4. Generate Session Name (Centralized Logic)
    # We calculate the name here so we don't repeat code for CLI args vs FZF args
    if is_worktree "$selected_path"; then
        local common_dir
        local branch_name
        local parent_name

        # Get git details
        common_dir=$(git -C "$selected_path" rev-parse --git-common-dir 2>/dev/null)
        branch_name=$(git -C "$selected_path" branch --show-current)

        # Clean up parent name (remove .git suffix)
        parent_name=$(basename "$common_dir" | sed 's/\.git$//')

        # Format: bare_name [branch]
        selected_name="${parent_name} [${branch_name}]"
    else
        # Regular directory: Normalize name (dots to underscores, lowercase first letter)
        selected_name=$(basename "$selected_path" | tr . _ | sed 's/^\(.\)/\L\1/')
    fi

    # 5. Create & Switch
    if ! has_session "$selected_name"; then
        tmux new-session -ds "$selected_name" -c "$selected_path"
        hydrate "$selected_name" "$selected_path"
    fi

    switch_to "$selected_name"
}

#------------------------------------------------------------------------------
# Entry Point
#------------------------------------------------------------------------------
main "$@"
