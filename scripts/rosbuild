#!/usr/bin/env bash
set -euo pipefail

# Default values
BUILD_TYPE="Debug"
PACKAGES=()
SANITIZER=""
CONFIG_FILE=".build.config"
VERBOSE=false
DRY_RUN=false
CCACHE_ENABLED=false
CLEAN_ONLY=false
RUN_TESTS=false
RUN_LINT=false
COMPILER=""
INSTALL_PREFIX=""
COVERAGE=false
BENCHMARK=false
VENV_DIR=".venv"
PYTHON_ENV_SETUP=false
nproc=$(nproc 2>/dev/null)
PARALLEL_JOBS=$((nproc / 4))
((PARALLEL_JOBS < 4)) && PARALLEL_JOBS=4

# Cross-compilation
CROSS_COMPILE=""

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Pre-allocate arrays for better performance
CMAKE_ARGS=(--cmake-args)
CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
CMAKE_CXX_FLAGS=()
COLCON_ARGS=()

# Cross-compilation toolchain configurations
declare -A CROSS_TOOLCHAINS=(
    # ARM 32-bit
    ["arm32_toolchain"]="arm-linux-gnueabihf"
    ["arm32_cmake_file"]="arm-linux-gnueabihf.cmake"
    ["arm32_arch"]="armv7-a"
    ["arm32_fpu"]="neon-vfpv4"
    ["arm32_processor"]="arm"

    # ARM 64-bit (aarch64)
    ["aarch64_toolchain"]="aarch64-linux-gnu"
    ["aarch64_cmake_file"]="aarch64-linux-gnu.cmake"
    ["aarch64_arch"]="armv8-a"
    ["aarch64_processor"]="aarch"

    # Raspberry Pi 3/4
    ["rpi3_toolchain"]="arm-linux-gnueabihf"
    ["rpi3_cmake_file"]="rpi3.cmake"
    ["rpi3_arch"]="armv8-a"
    ["rpi3_fpu"]="neon-fp-armv8"
    ["rpi3_processor"]="arm"

    ["rpi4_toolchain"]="aarch64-linux-gnu"
    ["rpi4_cmake_file"]="rpi4.cmake"
    ["rpi4_arch"]="armv8-a"
    ["rpi4_processor"]="aarch"
)
# Sanitizer configurations (centralized for maintainability)
declare -A SANITIZER_CONFIGS=(
    ["asan_linker"]="-fsanitize=address,undefined,leak"
    ["asan_cxx"]="-fsanitize=address,undefined,leak -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["asan_env"]="new_delete_type_mismatch=0:detect_leaks=1:strict_init_order=1:check_initialization_order=1:symbolize=1:verbosity=1"
    ["msan_linker"]="-fsanitize=memory"
    ["msan_cxx"]="-fsanitize=memory -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["msan_env"]="verbosity=1"
    ["tsan_linker"]="-fsanitize=thread -pie"
    ["tsan_cxx"]="-fsanitize=thread -fPIE"
    ["tsan_env"]="report_signal_unsafe=0:history_size=7:second_deadlock_stack=1:verbosity=1"
)

# Logging functions
log_info() { echo -e "${BLUE}‚Ñπ${NC} $*" >&2; }
log_success() { echo -e "${GREEN}‚úì${NC} $*" >&2; }
log_warning() { echo -e "${YELLOW}‚ö†${NC} $*" >&2; }
log_error() { echo -e "${RED}‚úó${NC} $*" >&2; }
log_docker() { echo -e "${CYAN}üê≥${NC} $*" >&2; }
log_cross() { echo -e "${MAGENTA}üîß${NC} $*" >&2; }

# Function to display help
show_help() {
    cat <<EOF
Usage: $0 [OPTIONS]

Build Options:
  -b, --build TYPE          Set build type (Debug|RelWithDebInfo|Release|MinSizeRel)
  -s, --sanitizer TYPE      Enable sanitizer (asan|msan|tsan)
  -p, --pkg LIST            Specify packages (comma or space-separated)
  -j, --jobs N              Number of parallel build jobs (default: $PARALLEL_JOBS)
  --compiler COMPILER       Use specific compiler (gcc|clang)
  --install-prefix PATH     Set custom install prefix

Cross-Compilation:
  --cross TARGET            Cross-compile for target (arm32|aarch64|rpi3|rpi4)
  --toolchain-file FILE     Custom CMake toolchain file
  --sysroot PATH            Sysroot path for cross-compilation

Advanced Build:
  --cmake-args FLAGS       Additional CMake flags
  --cxx-args FLAGS         Additional C++ compiler flags
  --colcon-args FLAGS      Additional colcon flags
  --ccache                  Enable ccache for faster rebuilds
  --coverage                Enable code coverage (implies Debug build)
  --benchmark               Enable benchmark builds with optimizations

Actions:
  --clean                   Clean build artifacts only (no build)
  --test                    Run tests after build
  --lint                    Run linters (clang-tidy, cppcheck)
  --dry-run                 Show build commands without executing
  -v, --verbose             Enable verbose output

Utilities:
  --stats                   Show build statistics
  --list-pkgs               List all packages in workspace
  --list-targets            List available cross-compilation targets
  --dependencies PKG        Show dependencies for a package
  -h, --help                Display this help message

Examples:
  # Standard builds
  $0 -b Release -p pkg1,pkg2
  $0 --build Debug --sanitizer asan --test
  $0 -p pkg1 pkg2 pkg3 --cmake-args -DENABLE_TESTING=ON
  $0 --ccache -j 8 --verbose
  $0 --clean --pkgs pkg1
  $0 --coverage --test

  # Cross-compilation
  $0 --cross aarch64 -b Release
  $0 --cross rpi4 -p navigation_pkg
EOF
    exit 0
}

# Function to list cross-compilation targets
list_cross_targets() {
    log_info "Available cross-compilation targets:"
    echo ""
    echo "  arm32      - ARM 32-bit (ARMv7-A with NEON)"
    echo "  aarch64    - ARM 64-bit (ARMv8-A)"
    echo "  rpi3       - Raspberry Pi 3 (32-bit ARMv8-A)"
    echo "  rpi4       - Raspberry Pi 4 (64-bit ARMv8-A)"
    echo ""
    echo "Usage: $0 --cross <target>"
    exit 0
}

# Function to check if command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Function to create CMake toolchain file
create_toolchain_file() {
    local target="$1"
    local toolchain_file="./${CROSS_TOOLCHAINS[${target}_cmake_file]}"
    local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"
    local arch="${CROSS_TOOLCHAINS[${target}_arch]}"
    local processor="${CROSS_TOOLCHAINS[${target}_processor]}"
    local fpu="${CROSS_TOOLCHAINS[${target}_fpu]:-}"

    log_cross "Creating toolchain file: $toolchain_file"

    cat >"$toolchain_file" <<EOF
# CMake toolchain file for ${target}
set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR ${processor})

# Cross-compiler settings
set(CMAKE_C_COMPILER ${toolchain_prefix}-gcc)
set(CMAKE_CXX_COMPILER ${toolchain_prefix}-g++)

# Compiler flags
set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} -march=${arch}" CACHE STRING "" FORCE)
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -march=${arch}" CACHE STRING "" FORCE)

EOF

    if [[ -n "$fpu" ]]; then
        cat >>"$toolchain_file" <<EOF
set(CMAKE_C_FLAGS "\${CMAKE_C_FLAGS} -mfpu=${fpu}" CACHE STRING "" FORCE)
set(CMAKE_CXX_FLAGS "\${CMAKE_CXX_FLAGS} -mfpu=${fpu}" CACHE STRING "" FORCE)
EOF
    fi

    cat >>"$toolchain_file" <<'EOF'

# Search paths
set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
EOF

    echo "$toolchain_file"
}

# Function to verify cross-compilation toolchain
verify_cross_toolchain() {
    local target="$1"
    local toolchain_prefix="${CROSS_TOOLCHAINS[${target}_toolchain]}"

    if ! command_exists "${toolchain_prefix}-gcc"; then
        log_error "Cross-compilation toolchain not found: ${toolchain_prefix}-gcc"
        log_info "Install with: sudo apt-get install gcc-${toolchain_prefix} g++-${toolchain_prefix}"
        exit 1
    fi

    log_success "Found cross-compiler: $(${toolchain_prefix}-gcc --version | head -n1)"
}

# Function to setup cross-compilation
setup_cross_compilation() {
    local target="$1"

    # Verify target exists
    if [[ -z "${CROSS_TOOLCHAINS[${target}_toolchain]:-}" ]]; then
        log_error "Unknown cross-compilation target: $target"
        log_info "Use --list-targets to see available targets"
        exit 1
    fi

    log_cross "Setting up cross-compilation for: $target"

    # Create toolchain file
    local toolchain_file
    toolchain_file=$(create_toolchain_file "$target")

    # Add toolchain file to CMake args
    CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="${PWD}/$toolchain_file")

    log_success "Cross-compilation configured for $target"
}
# Function to setup ccache
setup_ccache() {
    if command_exists ccache; then
        CMAKE_ARGS+=(-DCMAKE_CXX_COMPILER_LAUNCHER=ccache)
        CMAKE_ARGS+=(-DCMAKE_C_COMPILER_LAUNCHER=ccache)
        log_info "ccache enabled"

        # Show ccache stats if verbose
        if [[ "$VERBOSE" == true ]]; then
            ccache -s
        fi
    else
        log_warning "ccache not found, install with: sudo apt install ccache"
        CCACHE_ENABLED=false
    fi
}

# Function to setup compiler
setup_compiler() {
    case "$COMPILER" in
    gcc)
        CMAKE_ARGS+=(-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++)
        log_info "Using GCC compiler"
        ;;
    clang)
        CMAKE_ARGS+=(-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++)
        log_info "Using Clang compiler"
        ;;
    "")
        # Use default
        ;;
    *)
        log_error "Unknown compiler: $COMPILER"
        exit 1
        ;;
    esac
}

# Function to normalize build type
normalize_build_type() {
    local input="$1"
    case "${input,,}" in
    debug) echo "Debug" ;;
    release) echo "Release" ;;
    relwithdebinfo) echo "RelWithDebInfo" ;;
    minsizerel) echo "MinSizeRel" ;;
    *)
        log_error "Invalid build type '$input'"
        echo "Valid types: Debug, Release, RelWithDebInfo, MinSizeRel" >&2
        exit 1
        ;;
    esac
}

# Function to save build configuration
save_config() {
    {
        echo "PREV_BUILD_TYPE=$BUILD_TYPE"
        echo "PREV_SANITIZER=$SANITIZER"
        echo "PREV_COMPILER=$COMPILER"
        echo "PREV_COVERAGE=$COVERAGE"
        echo "PREV_CROSS_COMPILE=$CROSS_COMPILE"
    } >"$CONFIG_FILE"
}

# Function to load previous configuration
load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && return 0

    local line var_name var_value
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse variable assignment
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            var_value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present using parameter expansion
            var_value="${var_value#\"}"
            var_value="${var_value%\"}"
            declare -g "$var_name=$var_value"
        fi
    done < <(cat "$CONFIG_FILE")
}

# Function to check if rebuild is needed
check_rebuild_needed() {
    local needs_clean=false

    if [[ -n "${PREV_BUILD_TYPE:-}" && "$PREV_BUILD_TYPE" != "$BUILD_TYPE" ]]; then
        log_warning "Build type changed: $PREV_BUILD_TYPE ‚Üí $BUILD_TYPE"
        needs_clean=true
    fi

    if [[ -n "${PREV_SANITIZER:-}" && "$PREV_SANITIZER" != "$SANITIZER" ]]; then
        log_warning "Sanitizer changed: ${PREV_SANITIZER:-none} ‚Üí ${SANITIZER:-none}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COMPILER:-}" && "$PREV_COMPILER" != "$COMPILER" ]]; then
        log_warning "Compiler changed: ${PREV_COMPILER:-default} ‚Üí ${COMPILER:-default}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COVERAGE:-}" && "$PREV_COVERAGE" != "$COVERAGE" ]]; then
        log_warning "Coverage changed: ${PREV_COVERAGE} ‚Üí ${COVERAGE}"
        needs_clean=true
    fi

    if [[ -n "${PREV_CROSS_COMPILE:-}" && "$PREV_CROSS_COMPILE" != "$CROSS_COMPILE" ]]; then
        log_warning "Cross-compilation target changed: ${PREV_CROSS_COMPILE:-native} ‚Üí ${CROSS_COMPILE:-native}"
        needs_clean=true
    fi

    if [[ "$needs_clean" == true ]]; then
        log_info "Cleaning build cache (required for safe rebuild)..."
        COLCON_ARGS+=(--cmake-clean-first --cmake-clean-cache)
    fi
}

# Function to configure sanitizer
configure_sanitizer() {
    local sanitizer="$1"

    log_info "Configuring ${sanitizer^^} (forcing Debug mode)"
    BUILD_TYPE="Debug"

    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
    CMAKE_CXX_FLAGS+=("${SANITIZER_CONFIGS[${sanitizer}_cxx]}")

    cat <<EOF

To enable ${sanitizer^^}, run:
    export ${sanitizer^^}_OPTIONS="${SANITIZER_CONFIGS[${sanitizer}_env]}"

EOF
}

# Function to configure coverage
configure_coverage() {
    log_info "Enabling code coverage (forcing Debug mode)"
    BUILD_TYPE="Debug"
    CMAKE_CXX_FLAGS+=("-fprofile-arcs" "-ftest-coverage" "--coverage")
    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="--coverage")

    cat <<EOF

After running tests, generate coverage report with:
    lcov --capture --directory build --output-file coverage.info
    genhtml coverage.info --output-directory coverage_report

EOF
}

# Function to configure build type
configure_build_type() {
    case "$BUILD_TYPE" in
    Release)
        CMAKE_CXX_FLAGS+=("-O3" "-DNDEBUG")

        # Don't use -march=native for cross-compilation
        if [[ -z "$CROSS_COMPILE" &&
            ! "${CMAKE_CXX_FLAGS[*]}" =~ -march= ]]; then
            log_info "Using -march=native"
            CMAKE_CXX_FLAGS+=("-march=native")
        fi

        if [[ "$BENCHMARK" == true ]]; then
            CMAKE_CXX_FLAGS+=("-flto" "-ffast-math")
            log_info "Benchmark optimizations enabled (LTO, fast-math)"
        fi
        ;;
    Debug)
        CMAKE_CXX_FLAGS+=("-O0" "-g3" "-Wall" "-Wextra" "-Wpedantic")
        COLCON_ARGS+=(--symlink-install --continue-on-error)
        ;;
    RelWithDebInfo)
        CMAKE_CXX_FLAGS+=("-O2" "-g3" "-DNDEBUG")
        COLCON_ARGS+=(--symlink-install --continue-on-error)
        ;;
    MinSizeRel)
        CMAKE_CXX_FLAGS+=("-Os" "-DNDEBUG")
        ;;
    esac
}

# Function to clean build
clean_build() {
    log_info "Cleaning build artifacts..."

    rm -rf build/ install/ log/
    log_success "Cleaned all build artifacts"

    rm -f compile_commands.json "$CONFIG_FILE"
}

# Function to run tests
run_tests() {
    log_info "Running tests..."

    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        colcon test "${COLCON_ARGS[@]}"
        colcon test-result --verbose
    else
        colcon test --packages-select "${PACKAGES[@]}" "${COLCON_ARGS[@]}"
        colcon test-result --verbose --packages-select "${PACKAGES[@]}"
    fi
}

# Function to run linters
run_linters() {
    log_info "Running linters..."

    if command_exists clang-tidy && [[ -f compile_commands.json ]]; then
        log_info "Running clang-tidy..."
        tee clang-tidy.log < <(run-clang-tidy -p . 2>&1)
    fi

    if command_exists cppcheck; then
        log_info "Running cppcheck..."
        if [[ ${#PACKAGES[@]} -eq 0 ]]; then
            tee cppcheck.log < <(cppcheck --enable=all --suppress=missingIncludeSystem src/ 2>&1)
        else
            for pkg in "${PACKAGES[@]}"; do
                if [[ -d "src/$pkg" ]]; then
                    tee "cppcheck_$pkg.log" < <(cppcheck --enable=all --suppress=missingIncludeSystem "src/$pkg" 2>&1)
                fi
            done
        fi
    fi
}

# Function to list packages
list_packages() {
    log_info "Packages in workspace:"
    colcon list --names-only
    exit 0
}

# Function to show dependencies
show_dependencies() {
    local pkg="$1"
    log_info "Dependencies for package: $pkg"
    grep -v "^//" < <(colcon graph --packages-select "$pkg" --dot) || true
    exit 0
}

# Function to show build statistics
show_stats() {
    log_info "Build Statistics:"

    if [[ -d build ]]; then
        echo "Build directory size: $(du -sh build 2>/dev/null | cut -f1)"
    fi

    if [[ -d install ]]; then
        echo "Install directory size: $(du -sh install 2>/dev/null | cut -f1)"
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        echo ""
        echo "Last build configuration:"
        cat "$CONFIG_FILE"
    fi

    if command_exists ccache; then
        echo ""
        echo "ccache statistics:"
        ccache -s -v
    fi

    exit 0
}

setup_python_env() {
    log_info "Checking Python Virtual Environment..."

    # 1. Determine which directories to scan
    local search_targets=()

    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        return
    else
        # Case B: Specific packages listed. Resolve their paths.
        # We use 'colcon list' to get the exact path of each selected package
        log_info "Resolving paths for selected packages..."
        while IFS= read -r path; do
            [[ -n "$path" ]] && search_targets+=("$path")
        done < <(colcon list --packages-select "${PACKAGES[@]}" --paths-only 2>/dev/null)

        if [[ ${#search_targets[@]} -eq 0 ]]; then
            log_warning "Could not resolve paths for the selected packages. Skipping Python setup."
            return
        fi
    fi

    # 2. Create venv if missing
    if [[ ! -d "$VENV_DIR" ]]; then
        log_warning "Virtual environment not found. Creating at $VENV_DIR..."
        python3 -m venv "$VENV_DIR" --system-site-packages

        # Upgrade pip immediately
        "$VENV_DIR/bin/python" -m pip install --upgrade pip >/dev/null
        log_success "Virtual environment created."
    fi

    # 3. Iterate through resolved paths to setup environment
    for target in "${search_targets[@]}"; do
        [[ ! -d "$target" ]] && continue

        # A. Make scripts executable (Only matches */scripts/*.py inside the target)
        while IFS= read -r -d '' script_file; do
            if [[ ! -x "$script_file" ]]; then
                chmod +x "$script_file"
                log_success "Made executable: $script_file"
            fi
        done < <(find "$target" -type f -path "*/scripts/*.py" -print0)

        # B. Install requirements.txt
        while IFS= read -r -d '' req_file; do
            # Get package name from directory structure for cleaner logs
            local pkg_name
            pkg_name=$(basename "$(dirname "$req_file")")

            log_info "Installing dependencies for package: $pkg_name"
            "$VENV_DIR/bin/pip" install -r "$req_file" >/dev/null
        done < <(find "$target" -name "requirements.txt" -print0)
    done
}

# Main argument parsing
while [[ $# -gt 0 ]]; do
    case "$1" in
    -b | --build)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "-b requires an argument"
            exit 1
        }
        BUILD_TYPE=$(normalize_build_type "$2")
        shift 2
        ;;
    -s | --sanitizer)
        if [[ -n "${2:-}" && "$2" =~ ^(asan|msan|tsan)$ ]]; then
            SANITIZER="$2"
            shift 2
        else
            log_error "-s requires asan, msan, or tsan"
            exit 1
        fi
        ;;
    -p | --pkg)
        PACKAGES=()
        if [[ -n "${2:-}" && "$2" != -* ]]; then
            if [[ "$2" == *,* ]]; then
                IFS=',' read -ra PACKAGES <<<"$2"
                shift 2
            else
                shift
                while [[ $# -gt 0 && "$1" != -* ]]; do
                    PACKAGES+=("$1")
                    shift
                done
            fi
        else
            shift
        fi
        ;;
    -j | --jobs)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "-j requires a number"
            exit 1
        }
        PARALLEL_JOBS="$2"
        COLCON_ARGS+=(--parallel-workers "$PARALLEL_JOBS")
        shift 2
        ;;
    --compiler)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "--compiler requires gcc or clang"
            exit 1
        }
        COMPILER="$2"
        shift 2
        ;;
    --install-prefix)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "--install-prefix requires a path"
            exit 1
        }
        INSTALL_PREFIX="$2"
        shift 2
        ;;
    --cross)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "--cross requires a target"
            exit 1
        }
        CROSS_COMPILE="$2"
        shift 2
        ;;
    --toolchain-file)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "--toolchain-file requires a path"
            exit 1
        }
        CMAKE_ARGS+=(-DCMAKE_TOOLCHAIN_FILE="$2")
        shift 2
        ;;
    --sysroot)
        [[ -z "${2:-}" || "$2" == -* ]] && {
            log_error "--sysroot requires a path"
            exit 1
        }
        CMAKE_ARGS+=(-DCMAKE_SYSROOT="$2")
        shift 2
        ;;
    --cmake-args)
        shift
        while [[ $# -gt 0 && "$1" != --* ]]; do
            CMAKE_ARGS+=("$1")
            shift
        done
        ;;
    --cxx-args)
        shift
        while [[ $# -gt 0 && "$1" != --* ]]; do
            CMAKE_CXX_FLAGS+=("$1")
            shift
        done
        ;;
    --colcon-args)
        shift
        while [[ $# -gt 0 && "$1" != --* ]]; do
            COLCON_ARGS+=("--$1")
            shift
        done
        ;;
    --ccache)
        CCACHE_ENABLED=true
        shift
        ;;
    --coverage)
        COVERAGE=true
        shift
        ;;
    --benchmark)
        BENCHMARK=true
        BUILD_TYPE="Release"
        shift
        ;;
    --clean)
        CLEAN_ONLY=true
        shift
        ;;
    --test)
        RUN_TESTS=true
        shift
        ;;
    --python-env-setup)
        PYTHON_ENV_SETUP=true
        shift
        ;;
    --lint)
        RUN_LINT=true
        shift
        ;;
    --dry-run)
        DRY_RUN=true
        shift
        ;;
    -v | --verbose)
        VERBOSE=true
        shift
        ;;
    --stats)
        show_stats
        ;;
    --list-pkgs)
        list_packages
        ;;
    --list-targets)
        list_cross_targets
        ;;
    --dependencies)
        [[ -z "${2:-}" ]] && {
            log_error "--dependencies requires a package name"
            exit 1
        }
        show_dependencies "$2"
        ;;
    -h | --help)
        show_help
        ;;
    *)
        log_error "Unknown option '$1'"
        echo "Use -h or --help for usage information" >&2
        exit 1
        ;;
    esac
done

# Handle clean-only mode
if [[ "$CLEAN_ONLY" == true ]]; then
    clean_build
    exit 0
fi

# Main execution flow
load_config
check_rebuild_needed

# Setup cross-compilation
if [[ -n "$CROSS_COMPILE" ]]; then
    setup_cross_compilation "$CROSS_COMPILE"
fi

# Setup compiler
[[ -n "$COMPILER" ]] && setup_compiler

# Setup ccache
[[ "$CCACHE_ENABLED" == true ]] && setup_ccache

# Configure coverage
[[ "$COVERAGE" == true ]] && configure_coverage

# Configure sanitizer if requested
[[ -n "$SANITIZER" ]] && configure_sanitizer "$SANITIZER"

# Configure build type
configure_build_type

# Add install prefix if specified
[[ -n "$INSTALL_PREFIX" ]] && CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="$INSTALL_PREFIX")

# Finalize CMake arguments
CMAKE_ARGS+=(-DCMAKE_CXX_FLAGS="${CMAKE_CXX_FLAGS[*]}")
CMAKE_ARGS+=(-DCMAKE_BUILD_TYPE="$BUILD_TYPE")

# Add verbose flag if requested
[[ "$VERBOSE" == true ]] && COLCON_ARGS+=(--event-handlers console_direct+)

# Display build configuration
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "Build Configuration:"
echo "  Type: $BUILD_TYPE"
echo "  Packages: ${PACKAGES[*]:-all}"
echo "  Jobs: $PARALLEL_JOBS"
[[ -n "$COMPILER" ]] && echo "  Compiler: $COMPILER"
[[ -n "$CROSS_COMPILE" ]] && echo "  Cross-Compile: $CROSS_COMPILE"
[[ -n "$SANITIZER" ]] && echo "  Sanitizer: $SANITIZER"
[[ "$CCACHE_ENABLED" == true ]] && echo "  ccache: enabled"
[[ "$COVERAGE" == true ]] && echo "  Coverage: enabled"
[[ "$BENCHMARK" == true ]] && echo "  Benchmark: enabled"
[[ "$DRY_RUN" == true ]] && echo "  Mode: DRY RUN"
echo "  CMAKE_ARGS: ${CMAKE_ARGS[*]}"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

# Show build command in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
    log_info "Build command (dry-run):"
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        echo "colcon build ${COLCON_ARGS[*]} ${CMAKE_ARGS[*]}"
    else
        echo "colcon build --packages-up-to ${PACKAGES[*]} ${COLCON_ARGS[*]} ${CMAKE_ARGS[*]}"
    fi
    exit 0
fi

# Setup Python Environment (Before build)
if [[ "$PYTHON_ENV_SETUP" == true && "$DRY_RUN" == false && -z "$CROSS_COMPILE" ]]; then
    setup_python_env

    # 1. Activate Python Environment (in current script scope)
    if [[ -f "$VENV_DIR/bin/activate" && -z "$CROSS_COMPILE" ]]; then
        log_info "Activating Virtual Environment: $VENV_DIR"
        # Disabling unbound variable check briefly because activate scripts sometimes have unset vars
        set +u
        source "$VENV_DIR/bin/activate"
        set -u
    fi
fi

# Execute colcon build
START_TIME=$(date +%s)

# Run Build
if [[ ${#PACKAGES[@]} -eq 0 ]]; then
    colcon build "${COLCON_ARGS[@]}" "${CMAKE_ARGS[@]}"
else
    colcon build --packages-up-to "${PACKAGES[@]}" "${COLCON_ARGS[@]}" "${CMAKE_ARGS[@]}"
fi

END_TIME=$(date +%s)
BUILD_TIME=$((END_TIME - START_TIME))

# Save configuration
save_config

log_success "Build completed successfully in ${BUILD_TIME}s"

# Run tests if requested
[[ "$RUN_TESTS" == true ]] && run_tests

# Run linters if requested
[[ "$RUN_LINT" == true ]] && run_linters

# Show ccache stats at the end if verbose
if [[ "$VERBOSE" == true && "$CCACHE_ENABLED" == true ]]; then
    echo ""
    log_info "Final ccache statistics:"
    ccache -s
fi

# Cross-compilation reminder
if [[ -n "$CROSS_COMPILE" ]]; then
    echo ""
    log_cross "Cross-compilation completed for: $CROSS_COMPILE"
    log_info "Binaries are in: install/lib/"
    log_info "Transfer binaries to target device and ensure shared libraries are available"
fi
