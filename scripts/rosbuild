#!/usr/bin/env bash
set -euo pipefail

# Default values
BUILD_TYPE="Debug"
PACKAGES=()
SANITIZER=""
CONFIG_FILE=".build.config"
VERBOSE=false
DRY_RUN=false
CCACHE_ENABLED=false
CLEAN_ONLY=false
RUN_TESTS=false
RUN_LINT=false
COMPILER=""
INSTALL_PREFIX=""
COVERAGE=false
BENCHMARK=false
VENV_DIR=".venv"
PYTHON_ENV_SETUP=false
nproc=$(nproc 2>/dev/null)
PARALLEL_JOBS=$((nproc / 2))
((PARALLEL_JOBS < 4)) && PARALLEL_JOBS=4

# Build generator (auto-detect: ninja if available, else make)
CMAKE_GENERATOR=""

# Color codes for output (enhanced palette)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Pre-allocate arrays for better performance
CMAKE_ARGS=(--cmake-args)
CMAKE_ARGS+=(-DCMAKE_EXPORT_COMPILE_COMMANDS=ON)
CMAKE_CXX_FLAGS=(-fdiagnostics-color=always)
COLCON_ARGS=()

# Sanitizer configurations (centralized for maintainability)
declare -A SANITIZER_CONFIGS=(
    ["asan_linker"]="-fsanitize=address,undefined,leak"
    ["asan_cxx"]="-fsanitize=address,undefined,leak -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["asan_env"]="new_delete_type_mismatch=0:detect_leaks=1:strict_init_order=1:check_initialization_order=1:symbolize=1:verbosity=1"
    ["msan_linker"]="-fsanitize=memory"
    ["msan_cxx"]="-fsanitize=memory -fno-omit-frame-pointer -fno-optimize-sibling-calls"
    ["msan_env"]="verbosity=1"
    ["tsan_linker"]="-fsanitize=thread -pie"
    ["tsan_cxx"]="-fsanitize=thread -fPIE"
    ["tsan_env"]="report_signal_unsafe=0:history_size=7:second_deadlock_stack=1:verbosity=1"
)

# Logging functions with enhanced formatting
log_info() { echo -e "${BLUE}${BOLD}[INFO]${NC} ${BLUE}$*${NC}" >&2; }
log_success() { echo -e "${GREEN}${BOLD}[SUCCESS]${NC} ${GREEN}$*${NC}" >&2; }
log_warning() { echo -e "${YELLOW}${BOLD}[WARNING]${NC} ${YELLOW}$*${NC}" >&2; }
log_error() { echo -e "${RED}${BOLD}[ERROR]${NC} ${RED}$*${NC}" >&2; }
log_docker() { echo -e "${CYAN}${BOLD}[DOCKER]${NC} ${CYAN}$*${NC}" >&2; }
log_step() { echo -e "${BOLD}${BLUE}▶${NC} ${BOLD}$*${NC}" >&2; }
log_section() {
    echo -e "\n${BOLD}${CYAN}━━━━━━ $* ━━━━━━${NC}" >&2
}
print_separator() {
    echo -e "${DIM}────────────────────────────────────────────────────${NC}" >&2
}

# Function to display help
show_help() {
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${BOLD}${CYAN}  ROS 2 Workspace Build Script${NC}"
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo -e "${BOLD}USAGE:${NC}"
    echo "  $0 [OPTIONS]"
    echo ""
    echo -e "${BOLD}${GREEN}BUILD OPTIONS:${NC}"
    echo -e "  ${BOLD}-b, --build TYPE${NC}          Set build type (Debug|RelWithDebInfo|Release|MinSizeRel)"
    echo -e "  ${BOLD}-s, --sanitizer TYPE${NC}      Enable sanitizer (asan|msan|tsan)"
    echo -e "  ${BOLD}-p, --pkg LIST${NC}            Specify packages (comma or space-separated)"
    echo -e "  ${BOLD}-j, --jobs N${NC}              Number of parallel build jobs ${DIM}(default: $PARALLEL_JOBS)${NC}"
    echo -e "  ${BOLD}--compiler COMPILER${NC}       Use specific compiler (gcc|clang)"
    echo -e "  ${BOLD}--install-prefix PATH${NC}     Set custom install prefix"
    echo ""
    echo -e "${BOLD}${YELLOW}ADVANCED BUILD:${NC}"
    echo -e "  ${BOLD}--cmake-args FLAGS${NC}        Additional CMake flags"
    echo -e "  ${BOLD}--cxx-args FLAGS${NC}          Additional C++ compiler flags"
    echo -e "  ${BOLD}--colcon-args FLAGS${NC}       Additional colcon flags"
    echo -e "  ${BOLD}--generator TYPE${NC}          Build system generator ${DIM}(ninja|make, default: auto-detect)${NC}"
    echo -e "  ${BOLD}--ccache${NC}                  Enable ccache for faster rebuilds"
    echo -e "  ${BOLD}--coverage${NC}                Enable code coverage ${DIM}(implies Debug build)${NC}"
    echo -e "  ${BOLD}--benchmark${NC}               Enable benchmark builds with optimizations"
    echo ""
    echo -e "${BOLD}${BLUE}ACTIONS:${NC}"
    echo -e "  ${BOLD}--clean${NC}                   Clean build artifacts ${DIM}(use with -p to clean specific packages)${NC}"
    echo -e "  ${BOLD}--test${NC}                    Run tests after build"
    echo -e "  ${BOLD}--lint${NC}                    Run linters (clang-tidy, cppcheck)"
    echo -e "  ${BOLD}--dry-run${NC}                 Show build commands without executing"
    echo -e "  ${BOLD}-v, --verbose${NC}             Enable verbose output"
    echo ""
    echo -e "${BOLD}${CYAN}UTILITIES:${NC}"
    echo -e "  ${BOLD}--stats${NC}                   Show build statistics"
    echo -e "  ${BOLD}--list-pkgs${NC}               List all packages in workspace"
    echo -e "  ${BOLD}--dependencies PKG${NC}        Show dependencies for a package"
    echo -e "  ${BOLD}-h, --help${NC}                Display this help message"
    echo ""
    echo -e "${BOLD}${GREEN}EXAMPLES:${NC}"
    echo -e "  ${DIM}# Standard builds${NC}"
    echo "  $0 -b Release -p pkg1,pkg2"
    echo "  $0 --build Debug --sanitizer asan --test"
    echo "  $0 -p pkg1 pkg2 pkg3 --cmake-args -DENABLE_TESTING=ON"
    echo "  $0 --ccache -j 8 --verbose"
    echo ""
    echo -e "  ${DIM}# Cleaning${NC}"
    echo -e "  $0 --clean                      ${DIM}# Clean all packages${NC}"
    echo -e "  $0 --clean -p flight_manager    ${DIM}# Clean specific package${NC}"
    echo -e "  $0 --clean -p pkg1,pkg2,pkg3    ${DIM}# Clean multiple packages${NC}"
    echo ""
    echo -e "  ${DIM}# Coverage and testing${NC}"
    echo "  $0 --coverage --test"
    echo ""
    echo -e "${BOLD}${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    exit 0
}

# Function to check if command exists
command_exists() {
    command -v "$1" &>/dev/null
}

# Function to detect and setup build generator
setup_build_generator() {
    # If generator is explicitly set, use it
    if [[ -n "$CMAKE_GENERATOR" ]]; then
        case "${CMAKE_GENERATOR,,}" in
            ninja)
                if command_exists ninja; then
                    CMAKE_ARGS+=(-GNinja)
                    log_info "Using ${BOLD}Ninja${NC}${BLUE} build system (explicit)${NC}"
                else
                    log_error "Ninja not found. Install with: sudo apt install ninja-build"
                    exit 1
                fi
                ;;
            make | "unix makefiles")
                CMAKE_ARGS+=(-G"Unix Makefiles")
                log_info "Using ${BOLD}Unix Makefiles${NC}${BLUE} build system (explicit)${NC}"
                ;;
            *)
                log_error "Unknown generator: $CMAKE_GENERATOR"
                echo "Valid generators: ninja, make" >&2
                exit 1
                ;;
        esac
        return
    fi

    # Auto-detect: prefer Ninja if available
    if command_exists ninja; then
        CMAKE_ARGS+=(-GNinja)
        log_info "Using ${BOLD}Ninja${NC}${BLUE} build system (auto-detected)${NC}"
    else
        CMAKE_ARGS+=(-G"Unix Makefiles")
        log_info "Using ${BOLD}Unix Makefiles${NC}${BLUE} build system${NC}"
        log_warning "Install Ninja for faster builds: ${CYAN}sudo apt install ninja-build${NC}"
    fi
}

# Function to setup ccache
setup_ccache() {
    if command_exists ccache; then
        CMAKE_ARGS+=(-DCMAKE_CXX_COMPILER_LAUNCHER=ccache)
        CMAKE_ARGS+=(-DCMAKE_C_COMPILER_LAUNCHER=ccache)
        log_info "ccache enabled"

        # Show ccache stats if verbose
        if [[ "$VERBOSE" == true ]]; then
            ccache -s
        fi
    else
        log_warning "ccache not found, install with: sudo apt install ccache"
        CCACHE_ENABLED=false
    fi
}

# Function to setup compiler
setup_compiler() {
    case "$COMPILER" in
        gcc)
            CMAKE_ARGS+=(-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++)
            log_info "Using GCC compiler"
            ;;
        clang)
            CMAKE_ARGS+=(-DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++)
            log_info "Using Clang compiler"
            ;;
        "")
            # Use default
            ;;
        *)
            log_error "Unknown compiler: $COMPILER"
            exit 1
            ;;
    esac
}

# Function to normalize build type
normalize_build_type() {
    local input="$1"
    case "${input,,}" in
        debug) echo "Debug" ;;
        release) echo "Release" ;;
        relwithdebinfo) echo "RelWithDebInfo" ;;
        minsizerel) echo "MinSizeRel" ;;
        *)
            log_error "Invalid build type '$input'"
            echo "Valid types: Debug, Release, RelWithDebInfo, MinSizeRel" >&2
            exit 1
            ;;
    esac
}

# Function to save build configuration
save_config() {
    {
        echo "PREV_BUILD_TYPE=$BUILD_TYPE"
        echo "PREV_SANITIZER=$SANITIZER"
        echo "PREV_COMPILER=$COMPILER"
        echo "PREV_COVERAGE=$COVERAGE"
    } >"$CONFIG_FILE"
}

# Function to load previous configuration
load_config() {
    [[ ! -f "$CONFIG_FILE" ]] && return 0

    local line var_name var_value
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse variable assignment
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            var_value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present using parameter expansion
            var_value="${var_value#\"}"
            var_value="${var_value%\"}"
            declare -g "$var_name=$var_value"
        fi
    done < <(cat "$CONFIG_FILE")
}

# Function to check if rebuild is needed
check_rebuild_needed() {
    local needs_clean=false

    if [[ -n "${PREV_BUILD_TYPE:-}" && "$PREV_BUILD_TYPE" != "$BUILD_TYPE" ]]; then
        log_warning "Build type changed: ${BOLD}$PREV_BUILD_TYPE${NC}${YELLOW} → ${BOLD}$BUILD_TYPE${NC}"
        needs_clean=true
    fi

    if [[ -n "${PREV_SANITIZER:-}" && "$PREV_SANITIZER" != "$SANITIZER" ]]; then
        log_warning "Sanitizer changed: ${BOLD}${PREV_SANITIZER:-none}${NC}${YELLOW} → ${BOLD}${SANITIZER:-none}${NC}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COMPILER:-}" && "$PREV_COMPILER" != "$COMPILER" ]]; then
        log_warning "Compiler changed: ${BOLD}${PREV_COMPILER:-default}${NC}${YELLOW} → ${BOLD}${COMPILER:-default}${NC}"
        needs_clean=true
    fi

    if [[ -n "${PREV_COVERAGE:-}" && "$PREV_COVERAGE" != "$COVERAGE" ]]; then
        log_warning "Coverage changed: ${BOLD}${PREV_COVERAGE}${NC}${YELLOW} → ${BOLD}${COVERAGE}${NC}"
        needs_clean=true
    fi

    if [[ "$needs_clean" == true ]]; then
        log_info "Cleaning build cache ${DIM}(required for safe rebuild)${NC}"
        COLCON_ARGS+=(--cmake-clean-first --cmake-clean-cache)
    fi
}

# Function to configure sanitizer
configure_sanitizer() {
    local sanitizer="$1"

    log_info "Configuring ${BOLD}${sanitizer^^}${NC}${BLUE} sanitizer (forcing Debug mode)${NC}"
    BUILD_TYPE="Debug"

    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="${SANITIZER_CONFIGS[${sanitizer}_linker]}")
    CMAKE_CXX_FLAGS+=("${SANITIZER_CONFIGS[${sanitizer}_cxx]}")

    cat <<EOF

${BOLD}${YELLOW}To enable ${sanitizer^^}, run:${NC}
    ${GREEN}export ${sanitizer^^}_OPTIONS="${SANITIZER_CONFIGS[${sanitizer}_env]}"${NC}

EOF
}

# Function to configure coverage
configure_coverage() {
    log_info "Enabling code coverage ${DIM}(forcing Debug mode)${NC}"
    BUILD_TYPE="Debug"
    CMAKE_CXX_FLAGS+=("-fprofile-arcs" "-ftest-coverage" "--coverage")
    CMAKE_ARGS+=(-DCMAKE_EXE_LINKER_FLAGS="--coverage")

    cat <<EOF

${BOLD}${YELLOW}After running tests, generate coverage report with:${NC}
    ${GREEN}lcov --capture --directory build --output-file coverage.info${NC}
    ${GREEN}genhtml coverage.info --output-directory coverage_report${NC}

EOF
}

# Function to configure build type
configure_build_type() {
    case "$BUILD_TYPE" in
        Release)
            CMAKE_CXX_FLAGS+=("-O3" "-DNDEBUG")

            if [[ "$BENCHMARK" == true ]]; then
                CMAKE_CXX_FLAGS+=("-flto" "-ffast-math")
                log_info "Benchmark optimizations enabled (LTO, fast-math)"
            fi
            ;;
        Debug)
            CMAKE_CXX_FLAGS+=("-O0" "-g3" "-Wall" "-Wextra" "-Wpedantic")
            COLCON_ARGS+=(--symlink-install --continue-on-error)
            ;;
        RelWithDebInfo)
            CMAKE_CXX_FLAGS+=("-O2" "-g3" "-DNDEBUG")
            COLCON_ARGS+=(--symlink-install --continue-on-error)
            ;;
        MinSizeRel)
            CMAKE_CXX_FLAGS+=("-Os" "-DNDEBUG")
            ;;
    esac
}

# Function to clean build
clean_build() {
    log_section "Cleaning Build Artifacts"

    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        # Clean all packages
        echo -e "${BLUE}Removing all build artifacts:${NC}"
        echo -e "  ${DIM}- build/${NC}"
        echo -e "  ${DIM}- install/${NC}"
        echo -e "  ${DIM}- log/${NC}"
        echo -e "  ${DIM}- compile_commands.json${NC}"
        echo -e "  ${DIM}- ${CONFIG_FILE}${NC}"

        rm -rf build/ install/ log/
        rm -f compile_commands.json "$CONFIG_FILE"

        log_success "All build artifacts cleaned"
    else
        # Clean specific packages
        echo -e "${BLUE}Cleaning specific packages: ${BOLD}${GREEN}${PACKAGES[*]}${NC}"
        echo ""

        for pkg in "${PACKAGES[@]}"; do
            if [[ -d "build/$pkg" ]]; then
                echo -e "  ${DIM}- build/$pkg${NC}"
                rm -rf "build/$pkg"
            fi

            if [[ -d "install/$pkg" ]]; then
                echo -e "  ${DIM}- install/$pkg${NC}"
                rm -rf "install/$pkg"
            fi

            if [[ -d "log/$pkg" ]]; then
                echo -e "  ${DIM}- log/$pkg${NC}"
                rm -rf "log/$pkg"
            fi
        done

        # Also remove the package-specific entries from install/setup files
        if [[ -d "install" ]]; then
            log_info "Note: You may need to rebuild to update install/ setup files"
        fi

        log_success "Cleaned packages: ${BOLD}${PACKAGES[*]}${NC}"
    fi
}

# Function to run tests
run_tests() {
    log_info "Running tests..."

    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        colcon test "${COLCON_ARGS[@]}"
        colcon test-result --verbose
    else
        colcon test --packages-select "${PACKAGES[@]}" "${COLCON_ARGS[@]}"
        colcon test-result --verbose --packages-select "${PACKAGES[@]}"
    fi
}

# Function to run linters
run_linters() {
    log_info "Running linters..."

    if command_exists clang-tidy && [[ -f compile_commands.json ]]; then
        log_info "Running clang-tidy..."
        tee clang-tidy.log < <(run-clang-tidy -p . 2>&1)
    fi

    if command_exists cppcheck; then
        log_info "Running cppcheck..."
        if [[ ${#PACKAGES[@]} -eq 0 ]]; then
            tee cppcheck.log < <(cppcheck --enable=all --suppress=missingIncludeSystem src/ 2>&1)
        else
            for pkg in "${PACKAGES[@]}"; do
                if [[ -d "src/$pkg" ]]; then
                    tee "cppcheck_$pkg.log" < <(cppcheck --enable=all --suppress=missingIncludeSystem "src/$pkg" 2>&1)
                fi
            done
        fi
    fi
}

# Function to list packages
list_packages() {
    log_section "Packages in Workspace"
    echo ""
    colcon list --names-only | while read -r pkg; do
        echo -e "  ${GREEN}●${NC} ${BOLD}$pkg${NC}"
    done
    exit 0
}

# Function to show dependencies
show_dependencies() {
    local pkg="$1"
    log_info "Dependencies for package: $pkg"
    grep -v "^//" < <(colcon graph --packages-select "$pkg" --dot) || true
    exit 0
}

# Function to show build statistics
show_stats() {
    log_section "Build Statistics"
    echo ""

    if [[ -d build ]]; then
        echo -e "${BOLD}Build directory size:${NC} ${GREEN}$(du -sh build 2>/dev/null | cut -f1)${NC}"
    fi

    if [[ -d install ]]; then
        echo -e "${BOLD}Install directory size:${NC} ${GREEN}$(du -sh install 2>/dev/null | cut -f1)${NC}"
    fi

    if [[ -f "$CONFIG_FILE" ]]; then
        echo ""
        echo -e "${BOLD}${CYAN}Last build configuration:${NC}"
        print_separator
        while IFS= read -r line; do
            echo -e "${DIM}  $line${NC}"
        done <"$CONFIG_FILE"
        print_separator
    fi

    if command_exists ccache; then
        echo ""
        echo -e "${BOLD}${CYAN}ccache statistics:${NC}"
        print_separator
        ccache -s -v
        print_separator
    fi

    exit 0
}

setup_python_env() {
    log_section "Python Virtual Environment Setup"

    # 1. Determine which directories to scan
    local search_targets=()

    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        return
    else
        # Case B: Specific packages listed. Resolve their paths.
        # We use 'colcon list' to get the exact path of each selected package
        log_info "Resolving paths for selected packages..."
        while IFS= read -r path; do
            [[ -n "$path" ]] && search_targets+=("$path")
        done < <(colcon list --packages-select "${PACKAGES[@]}" --paths-only 2>/dev/null)

        if [[ ${#search_targets[@]} -eq 0 ]]; then
            log_warning "Could not resolve paths for the selected packages. Skipping Python setup."
            return
        fi
    fi

    # 2. Create venv if missing
    if [[ ! -d "$VENV_DIR" ]]; then
        log_warning "Virtual environment not found. Creating at ${CYAN}$VENV_DIR${NC}"
        python3 -m venv "$VENV_DIR" --system-site-packages

        # Upgrade pip immediately
        "$VENV_DIR/bin/python" -m pip install --upgrade pip >/dev/null
        log_success "Virtual environment created"
    fi

    # 3. Iterate through resolved paths to setup environment
    for target in "${search_targets[@]}"; do
        [[ ! -d "$target" ]] && continue

        # A. Make scripts executable (Only matches */scripts/*.py inside the target)
        while IFS= read -r -d '' script_file; do
            if [[ ! -x "$script_file" ]]; then
                chmod +x "$script_file"
                log_success "Made executable: ${DIM}$script_file${NC}"
            fi
        done < <(find "$target" -type f -path "*/scripts/*.py" -print0)

        # B. Install requirements.txt
        while IFS= read -r -d '' req_file; do
            # Get package name from directory structure for cleaner logs
            local pkg_name
            pkg_name=$(basename "$(dirname "$req_file")")

            log_info "Installing dependencies for package: ${BOLD}${GREEN}$pkg_name${NC}"
            "$VENV_DIR/bin/pip" install -r "$req_file" >/dev/null
        done < <(find "$target" -name "requirements.txt" -print0)
    done
}

# Main argument parsing
while [[ $# -gt 0 ]]; do
    case "$1" in
        -b | --build)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-b requires an argument"
                exit 1
            }
            BUILD_TYPE=$(normalize_build_type "$2")
            shift 2
            ;;
        -s | --sanitizer)
            if [[ -n "${2:-}" && "$2" =~ ^(asan|msan|tsan)$ ]]; then
                SANITIZER="$2"
                shift 2
            else
                log_error "-s requires asan, msan, or tsan"
                exit 1
            fi
            ;;
        -p | --pkg)
            PACKAGES=()
            if [[ -n "${2:-}" && "$2" != -* ]]; then
                if [[ "$2" == *,* ]]; then
                    IFS=',' read -ra PACKAGES <<<"$2"
                    shift 2
                else
                    shift
                    while [[ $# -gt 0 && "$1" != -* ]]; do
                        PACKAGES+=("$1")
                        shift
                    done
                fi
            else
                shift
            fi
            ;;
        -j | --jobs)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "-j requires a number"
                exit 1
            }
            PARALLEL_JOBS="$2"
            COLCON_ARGS+=(--parallel-workers "$PARALLEL_JOBS")
            shift 2
            ;;
        --compiler)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--compiler requires gcc or clang"
                exit 1
            }
            COMPILER="$2"
            shift 2
            ;;
        --install-prefix)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--install-prefix requires a path"
                exit 1
            }
            INSTALL_PREFIX="$2"
            shift 2
            ;;
        --generator)
            [[ -z "${2:-}" || "$2" == -* ]] && {
                log_error "--generator requires ninja or make"
                exit 1
            }
            CMAKE_GENERATOR="$2"
            shift 2
            ;;
        --cmake-args)
            shift
            while [[ $# -gt 0 && "$1" != --* ]]; do
                CMAKE_ARGS+=("$1")
                shift
            done
            ;;
        --cxx-args)
            shift
            while [[ $# -gt 0 && "$1" != --* ]]; do
                CMAKE_CXX_FLAGS+=("$1")
                shift
            done
            ;;
        --colcon-args)
            shift
            while [[ $# -gt 0 && "$1" != --* ]]; do
                COLCON_ARGS+=("--$1")
                shift
            done
            ;;
        --ccache)
            CCACHE_ENABLED=true
            shift
            ;;
        --coverage)
            COVERAGE=true
            shift
            ;;
        --benchmark)
            BENCHMARK=true
            BUILD_TYPE="Release"
            shift
            ;;
        --clean)
            CLEAN_ONLY=true
            shift
            ;;
        --test)
            RUN_TESTS=true
            shift
            ;;
        --python-env-setup)
            PYTHON_ENV_SETUP=true
            shift
            ;;
        --lint)
            RUN_LINT=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -v | --verbose)
            VERBOSE=true
            shift
            ;;
        --stats)
            show_stats
            ;;
        --list-pkgs)
            list_packages
            ;;
        --dependencies)
            [[ -z "${2:-}" ]] && {
                log_error "--dependencies requires a package name"
                exit 1
            }
            show_dependencies "$2"
            ;;
        -h | --help)
            show_help
            ;;
        *)
            log_error "Unknown option '$1'"
            echo "Use -h or --help for usage information" >&2
            exit 1
            ;;
    esac
done

# Handle clean-only mode
if [[ "$CLEAN_ONLY" == true ]]; then
    clean_build
    exit 0
fi

# Main execution flow
load_config
check_rebuild_needed

# Setup build generator (Ninja or Make)
setup_build_generator

# Setup compiler
[[ -n "$COMPILER" ]] && setup_compiler

# Setup ccache
[[ "$CCACHE_ENABLED" == true ]] && setup_ccache

# Configure coverage
[[ "$COVERAGE" == true ]] && configure_coverage

# Configure sanitizer if requested
[[ -n "$SANITIZER" ]] && configure_sanitizer "$SANITIZER"

# Configure build type
configure_build_type

# Add install prefix if specified
[[ -n "$INSTALL_PREFIX" ]] && CMAKE_ARGS+=(-DCMAKE_INSTALL_PREFIX="$INSTALL_PREFIX")

# Finalize CMake arguments
CMAKE_ARGS+=(-DCMAKE_CXX_FLAGS="${CMAKE_CXX_FLAGS[*]}")
CMAKE_ARGS+=(-DCMAKE_BUILD_TYPE="$BUILD_TYPE")

# Add verbose flag if requested
[[ "$VERBOSE" == true ]] && COLCON_ARGS+=(--event-handlers console_direct+)

# Display build configuration
echo ""
log_section "Build Configuration"
echo ""
echo -e "  ${BOLD}Type:${NC}           ${GREEN}$BUILD_TYPE${NC}"
echo -e "  ${BOLD}Packages:${NC}       ${CYAN}${PACKAGES[*]:-all}${NC}"
echo -e "  ${BOLD}Jobs:${NC}           ${YELLOW}$PARALLEL_JOBS${NC}"
[[ -n "$COMPILER" ]] && echo -e "  ${BOLD}Compiler:${NC}       ${BLUE}$COMPILER${NC}"
[[ -n "$SANITIZER" ]] && echo -e "  ${BOLD}Sanitizer:${NC}      ${YELLOW}$SANITIZER${NC}"
[[ "$CCACHE_ENABLED" == true ]] && echo -e "  ${BOLD}ccache:${NC}         ${GREEN}enabled${NC}"
[[ "$COVERAGE" == true ]] && echo -e "  ${BOLD}Coverage:${NC}       ${GREEN}enabled${NC}"
[[ "$BENCHMARK" == true ]] && echo -e "  ${BOLD}Benchmark:${NC}      ${GREEN}enabled${NC}"
[[ "$DRY_RUN" == true ]] && echo -e "  ${BOLD}Mode:${NC}           ${YELLOW}DRY RUN${NC}"
echo ""
echo -e "${DIM}CMAKE_ARGS: ${CMAKE_ARGS[*]}${NC}"
print_separator
echo ""

# Show build command in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
    log_section "Dry Run Mode - Build Command"
    echo ""
    if [[ ${#PACKAGES[@]} -eq 0 ]]; then
        echo -e "${GREEN}colcon build ${COLCON_ARGS[*]} ${CMAKE_ARGS[*]}${NC}"
    else
        echo -e "${GREEN}colcon build --packages-up-to ${PACKAGES[*]} ${COLCON_ARGS[*]} ${CMAKE_ARGS[*]}${NC}"
    fi
    echo ""
    exit 0
fi

# Setup Python Environment (Before build)
if [[ "$PYTHON_ENV_SETUP" == true && "$DRY_RUN" == false ]]; then
    setup_python_env

    # 1. Activate Python Environment (in current script scope)
    if [[ -f "$VENV_DIR/bin/activate" ]]; then
        log_info "Activating Virtual Environment: $VENV_DIR"
        # Disabling unbound variable check briefly because activate scripts sometimes have unset vars
        set +u
        source "$VENV_DIR/bin/activate"
        set -u
    fi
fi

# Execute colcon build
log_section "Starting Build"
START_TIME=$(date +%s)

# Run Build
if [[ ${#PACKAGES[@]} -eq 0 ]]; then
    log_step "Building all packages..."
    colcon build "${COLCON_ARGS[@]}" "${CMAKE_ARGS[@]}"
else
    log_step "Building packages: ${BOLD}${GREEN}${PACKAGES[*]}${NC}"
    colcon build --packages-up-to "${PACKAGES[@]}" "${COLCON_ARGS[@]}" "${CMAKE_ARGS[@]}"
fi

END_TIME=$(date +%s)
BUILD_TIME=$((END_TIME - START_TIME))

# Save configuration
save_config

echo ""
log_success "Build completed successfully in ${BOLD}${BUILD_TIME}s${NC}"

# Run tests if requested
if [[ "$RUN_TESTS" == true ]]; then
    echo ""
    run_tests
    log_success "Tests completed"
fi

# Run linters if requested
if [[ "$RUN_LINT" == true ]]; then
    echo ""
    run_linters
    log_success "Linting completed"
fi

# Show ccache stats at the end if verbose
if [[ "$VERBOSE" == true && "$CCACHE_ENABLED" == true ]]; then
    echo ""
    log_section "Final ccache Statistics"
    ccache -s
fi
